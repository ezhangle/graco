----------------------
27/02/2019 18:01:54 - C:\Projects\repos\ioninja\graco\include\llk_Ast.h
----------------------
[-] 	axl::sl::Array <AstNode*> m_children;
[+] 	axl::sl::Array<AstNode*> m_children;
[-] 	AstNode ()
[+] 	AstNode()
[-] 	~AstNode () // could be subclassed
[+] 	~AstNode() // could be subclassed
[-] 	axl::sl::List <AstNode> m_list;
[+] 	axl::sl::List<AstNode> m_list;
[-] 	Ast ()
[+] 	Ast()
[-] 	getRoot ()
[+] 	getRoot()
[-] 	clear ()
[+] 	clear()
[-] 		m_list.clear ();
[+] 		m_list.clear();
[-] 	add (AstNode* astNode)
[+] 	add(AstNode* astNode)
[-] 		m_list.insertTail (astNode);
[+] 		m_list.insertTail(astNode);
----------------------
27/02/2019 18:01:54 - C:\Projects\repos\ioninja\graco\include\llk_Node.h
----------------------
[-] getNodeKindString (NodeKind nodeKind)
[+] getNodeKindString(NodeKind nodeKind)
[-] 	static const char* stringTable [NodeKind__Count] =
[+] 	static const char* stringTable[NodeKind__Count] =
[-] 		stringTable [nodeKind] :
[+] 		stringTable[nodeKind] :
[-] 		stringTable [NodeKind_Undefined];
[+] 		stringTable[NodeKind_Undefined];
[-] 	Node ()
[+] 	Node()
[-] 	~Node ()
[+] 	~Node()
[-] 	getNodeKindString ()
[+] 	getNodeKindString()
[-] 		return llk::getNodeKindString (m_kind);
[+] 		return llk::getNodeKindString(m_kind);
[-] 	TokenNode ()
[+] 	TokenNode()
[-] 	axl::sl::List <Node> m_locatorList;
[+] 	axl::sl::List<Node> m_locatorList;
[-] 	axl::sl::Array <Node*> m_locatorArray;
[+] 	axl::sl::Array<Node*> m_locatorArray;
[-] 	SymbolNode ()
[+] 	SymbolNode()
[-] 	~SymbolNode ()
[+] 	~SymbolNode()
[-] 			AXL_MEM_DELETE (m_astNode);
[+] 			AXL_MEM_DELETE(m_astNode);
[-] 	axl::sl::BoxIterator <Token> m_reparseLaDfaTokenCursor;
[+] 	axl::sl::BoxIterator<Token> m_reparseLaDfaTokenCursor;
[-] 	axl::sl::BoxIterator <Token> m_reparseResolverTokenCursor;
[+] 	axl::sl::BoxIterator<Token> m_reparseResolverTokenCursor;
[-] 	LaDfaNode ()
[+] 	LaDfaNode()
----------------------
27/02/2019 18:01:54 - C:\Projects\repos\ioninja\graco\include\llk_Parser.h
----------------------
[-] 	typedef llk::AstNode <Token> AstNode;
[+] 	typedef llk::AstNode<Token> AstNode;
[-] 	typedef llk::Ast <AstNode> Ast;
[+] 	typedef llk::Ast<AstNode> Ast;
[-] 	typedef llk::TokenNode <Token> TokenNode;
[+] 	typedef llk::TokenNode<Token> TokenNode;
[-] 	typedef llk::SymbolNode <AstNode> SymbolNode;
[+] 	typedef llk::SymbolNode<AstNode> SymbolNode;
[-] 	typedef llk::LaDfaNode <Token> LaDfaNode;
[+] 	typedef llk::LaDfaNode<Token> LaDfaNode;
[-] 	axl::sl::List <Node> m_nodeList;
[+] 	axl::sl::List<Node> m_nodeList;
[-] 	axl::ref::Buf <Ast> m_ast;
[+] 	axl::ref::Buf<Ast> m_ast;
[-] 	axl::sl::Array <Node*> m_predictionStack;
[+] 	axl::sl::Array<Node*> m_predictionStack;
[-] 	axl::sl::Array <SymbolNode*> m_symbolStack;
[+] 	axl::sl::Array<SymbolNode*> m_symbolStack;
[-] 	axl::sl::Array <LaDfaNode*> m_resolverStack;
[+] 	axl::sl::Array<LaDfaNode*> m_resolverStack;
[-] 	axl::sl::BoxList <Token> m_tokenList;
[+] 	axl::sl::BoxList<Token> m_tokenList;
[-] 	axl::sl::BoxIterator <Token> m_tokenCursor;
[+] 	axl::sl::BoxIterator<Token> m_tokenCursor;
[-] 	Parser ()
[+] 	Parser()
[-] 	create (
[+] 	create(
[-] 		clear ();
[+] 		clear();
[-] 		return (SymbolNode*) pushPrediction (T::SymbolFirst + symbol);
[+] 		return (SymbolNode*)pushPrediction(T::SymbolFirst + symbol);
[-] 	axl::ref::Buf <Ast>
[+] 	axl::ref::Buf<Ast>
[-] 	getAst ()
[+] 	getAst()
[-] 	clear ()
[+] 	clear()
[-] 		m_nodeList.clear ();
[+] 		m_nodeList.clear();
[-] 		m_predictionStack.clear ();
[+] 		m_predictionStack.clear();
[-] 		m_symbolStack.clear ();
[+] 		m_symbolStack.clear();
[-] 		m_resolverStack.clear ();
[+] 		m_resolverStack.clear();
[-] 		m_tokenList.clear ();
[+] 		m_tokenList.clear();
[-] 		m_ast.release ();
[+] 		m_ast.release();
[-] 	parseToken (const Token* token)
[+] 	parseToken(const Token* token)
[-] 		m_tokenCursor = m_tokenList.insertTail (*token);
[+] 		m_tokenCursor = m_tokenList.insertTail(*token);
[-] 		size_t* parseTable = static_cast <T*> (this)->getParseTable ();
[+] 		size_t* parseTable = static_cast<T*> (this)->getParseTable();
[-] 		size_t tokenIndex = static_cast <T*> (this)->getTokenIndex (token->m_token);
[+] 		size_t tokenIndex = static_cast<T*> (this)->getTokenIndex(token->m_token);
[-] 		ASSERT (tokenIndex < T::TokenCount);
[+] 		ASSERT(tokenIndex < T::TokenCount);
[-] 			size_t productionIndex = parseTable [T::StartPragmaSymbol * T::TokenCount + tokenIndex];
[+] 			size_t productionIndex = parseTable[T::StartPragmaSymbol * T::TokenCount + tokenIndex];
[-] 				pushPrediction (productionIndex);
[+] 				pushPrediction(productionIndex);
[-] 			Node* node = getPredictionTop ();
[+] 			Node* node = getPredictionTop();
[-] 				matchResult = matchEmptyPredictionStack ();
[+] 				matchResult = matchEmptyPredictionStack();
[-] 				switch (node->m_kind)
[+] 				switch(node->m_kind)
[-] 					matchResult = matchTokenNode ((TokenNode*) node, tokenIndex);
[+] 					matchResult = matchTokenNode((TokenNode*)node, tokenIndex);
[-] 					matchResult = matchSymbolNode ((SymbolNode*) node, parseTable, tokenIndex);
[+] 					matchResult = matchSymbolNode((SymbolNode*)node, parseTable, tokenIndex);
[-] 					matchResult = matchSequenceNode (node);
[+] 					matchResult = matchSequenceNode(node);
[-] 					matchResult = matchActionNode (node);
[+] 					matchResult = matchActionNode(node);
[-] 					ASSERT (node->m_flags & NodeFlag_Matched); // was handled during matching ENode_Symbol
[+] 					ASSERT(node->m_flags & NodeFlag_Matched); // was handled during matching ENode_Symbol
[-] 					popPrediction ();
[+] 					popPrediction();
[-] 					matchResult = matchLaDfaNode ((LaDfaNode*) node);
[+] 					matchResult = matchLaDfaNode((LaDfaNode*)node);
[-] 					ASSERT (false);
[+] 					ASSERT(false);
[-] 				if (m_resolverStack.isEmpty ())
[+] 				if (m_resolverStack.isEmpty())
[-] 				matchResult = rollbackResolver ();
[+] 				matchResult = rollbackResolver();
[-] 				ASSERT (matchResult != MatchResult_Fail); // failed resolver means there is another possibility!
[+] 				ASSERT(matchResult != MatchResult_Fail); // failed resolver means there is another possibility!
[-] 			switch (matchResult)
[+] 			switch(matchResult)
[-] 				result = advanceTokenCursor ();
[+] 				result = advanceTokenCursor();
[-] 				tokenIndex = static_cast <T*> (this)->getTokenIndex (m_currentToken.m_token);
[+] 				tokenIndex = static_cast<T*> (this)->getTokenIndex(m_currentToken.m_token);
[-] 				ASSERT (tokenIndex < T::TokenCount);
[+] 				ASSERT(tokenIndex < T::TokenCount);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 	traceSymbolStack ()
[+] 	traceSymbolStack()
[-] 		intptr_t count = m_symbolStack.getCount ();
[+] 		intptr_t count = m_symbolStack.getCount();
[-] 		TRACE ("SYMBOL STACK (%d symbols):\n", count);
[+] 		TRACE("SYMBOL STACK (%d symbols):\n", count);
[-] 			SymbolNode* node = m_symbolStack [i];
[+] 			SymbolNode* node = m_symbolStack[i];
[-] 			TRACE ("%s", static_cast <T*> (this)->getSymbolName (node->m_index));
[+] 			TRACE("%s", static_cast <T*> (this)->getSymbolName (node->m_index));
[-] 				TRACE (" (%d:%d)", node->m_astNode->m_firstToken.m_pos.m_line + 1, node->m_astNode->m_firstToken.m_pos.m_col + 1);
[+] 				TRACE(" (%d:%d)", node->m_astNode->m_firstToken.m_pos.m_line + 1, node->m_astNode->m_firstToken.m_pos.m_col + 1);
[-] 			TRACE ("\n");
[+] 			TRACE("\n");
[-] 	tracePredictionStack ()
[+] 	tracePredictionStack()
[-] 		intptr_t count = m_predictionStack.getCount ();
[+] 		intptr_t count = m_predictionStack.getCount();
[-] 		TRACE ("PREDICTION STACK (%d nodes):\n", count);
[+] 		TRACE("PREDICTION STACK (%d nodes):\n", count);
[-] 			Node* node = m_predictionStack [i];
[+] 			Node* node = m_predictionStack[i];
[-] 			TRACE ("%s (%d)\n", getNodeKindString (node->m_kind), node->m_index);
[+] 			TRACE("%s (%d)\n", getNodeKindString (node->m_kind), node->m_index);
[-] 	traceTokenList ()
[+] 	traceTokenList()
[-] 		axl::sl::BoxIterator <Token> token = m_tokenList.getHead ();
[+] 		axl::sl::BoxIterator<Token> token = m_tokenList.getHead();
[-] 		TRACE ("TOKEN LIST (%d tokens):\n", m_tokenList.getCount ());
[+] 		TRACE("TOKEN LIST (%d tokens):\n", m_tokenList.getCount ());
[-] 			TRACE ("%s '%s' %s\n", token->getName (), token->getText (), token == m_tokenCursor ? "<--" : "");
[+] 			TRACE("%s '%s' %s\n", token->getName (), token->getText (), token == m_tokenCursor ? "<--" : "");
[-] 	getLastMatchedToken ()
[+] 	getLastMatchedToken()
[-] 	getCurrentToken ()
[+] 	getCurrentToken()
[-] 	getPredictionTop ()
[+] 	getPredictionTop()
[-] 		size_t count = m_predictionStack.getCount ();
[+] 		size_t count = m_predictionStack.getCount();
[-] 		return count ? m_predictionStack [count - 1] : NULL;
[+] 		return count ? m_predictionStack[count - 1] : NULL;
[-] 	getSymbolStackSize ()
[+] 	getSymbolStackSize()
[-] 		return m_symbolStack.getCount ();
[+] 		return m_symbolStack.getCount();
[-] 	getSymbolTop ()
[+] 	getSymbolTop()
[-] 		size_t count = m_symbolStack.getCount ();
[+] 		size_t count = m_symbolStack.getCount();
[-] 		return count ? m_symbolStack [count - 1] : NULL;
[+] 		return count ? m_symbolStack[count - 1] : NULL;
[-] 	advanceTokenCursor ()
[+] 	advanceTokenCursor()
[-] 		Node* node = getPredictionTop ();
[+] 		Node* node = getPredictionTop();
[-] 		if (m_resolverStack.isEmpty () && (!node || node->m_kind != NodeKind_LaDfa))
[+] 		if (m_resolverStack.isEmpty() && (!node || node->m_kind != NodeKind_LaDfa))
[-] 			m_tokenList.removeHead (); // nobody gonna reparse you
[+] 			m_tokenList.removeHead(); // nobody gonna reparse you
[-] 			ASSERT (m_tokenCursor == m_tokenList.getHead());
[+] 			ASSERT(m_tokenCursor == m_tokenList.getHead());
[-] 	matchEmptyPredictionStack ()
[+] 	matchEmptyPredictionStack()
[-] 		axl::err::setFormatStringError ("prediction stack empty while parsing '%s'", m_currentToken.getName ());
[+] 		axl::err::setFormatStringError("prediction stack empty while parsing '%s'", m_currentToken.getName ());
[-] 	matchTokenNode (
[+] 	matchTokenNode(
[-] 			if (m_resolverStack.isEmpty ()) // can't rollback so set error
[+] 			if (m_resolverStack.isEmpty()) // can't rollback so set error
[-] 				int expectedToken = static_cast <T*> (this)->getTokenFromIndex (node->m_index);
[+] 				int expectedToken = static_cast<T*> (this)->getTokenFromIndex(node->m_index);
[-] 				axl::lex::setExpectedTokenError (Token::getName (expectedToken), m_currentToken.getName ());
[+] 				axl::lex::setExpectedTokenError(Token::getName(expectedToken), m_currentToken.getName());
[-] 		popPrediction ();
[+] 		popPrediction();
[-] 	matchSymbolNode (
[+] 	matchSymbolNode(
[-] 			SymbolNode* top = getSymbolTop ();
[+] 			SymbolNode* top = getSymbolTop();
[-] 			ASSERT (getSymbolTop () == node);
[+] 			ASSERT(getSymbolTop() == node);
[-] 				result = static_cast <T*> (this)->leave (node->m_index);
[+] 				result = static_cast<T*> (this)->leave(node->m_index);
[-] 			popSymbol ();
[+] 			popSymbol();
[-] 			popPrediction ();
[+] 			popPrediction();
[-] 			Node* argument = getArgument ();
[+] 			Node* argument = getArgument();
[-] 				static_cast <T*> (this)->argument (argument->m_index, node);
[+] 				static_cast<T*> (this)->argument(argument->m_index, node);
[-] 			pushSymbol (node);
[+] 			pushSymbol(node);
[-] 				result = static_cast <T*> (this)->enter (node->m_index);
[+] 				result = static_cast<T*> (this)->enter(node->m_index);
[-] 		size_t productionIndex = parseTable [node->m_index * T::TokenCount + tokenIndex];
[+] 		size_t productionIndex = parseTable[node->m_index * T::TokenCount + tokenIndex];
[-] 			if (m_resolverStack.isEmpty ()) // can't rollback so set error
[+] 			if (m_resolverStack.isEmpty()) // can't rollback so set error
[-] 				SymbolNode* symbol = getSymbolTop ();
[+] 				SymbolNode* symbol = getSymbolTop();
[-] 				ASSERT (symbol);
[+] 				ASSERT(symbol);
[-] 				axl::err::setFormatStringError (
[+] 				axl::err::setFormatStringError(
[-] 					m_currentToken.getName (),
[+] 					m_currentToken.getName(),
[-] 					static_cast <T*> (this)->getSymbolName (symbol->m_index)
[+] 					static_cast<T*> (this)->getSymbolName(symbol->m_index)
[-] 		ASSERT (productionIndex < T::TotalCount);
[+] 		ASSERT(productionIndex < T::TotalCount);
[-] 			popPrediction ();
[+] 			popPrediction();
[-] 		pushPrediction (productionIndex);
[+] 		pushPrediction(productionIndex);
[-] 	matchSequenceNode (Node* node)
[+] 	matchSequenceNode(Node* node)
[-] 		size_t* p = static_cast <T*> (this)->getSequence (node->m_index);
[+] 		size_t* p = static_cast<T*> (this)->getSequence(node->m_index);
[-] 		popPrediction ();
[+] 		popPrediction();
[-] 			pushPrediction (*p);
[+] 			pushPrediction(*p);
[-] 	matchActionNode (Node* node)
[+] 	matchActionNode(Node* node)
[-] 		bool result = static_cast <T*> (this)->action (node->m_index);
[+] 		bool result = static_cast<T*> (this)->action(node->m_index);
[-] 		popPrediction ();
[+] 		popPrediction();
[-] 	matchLaDfaNode (LaDfaNode* node)
[+] 	matchLaDfaNode(LaDfaNode* node)
[-] 			ASSERT (getPreResolverTop () == node);
[+] 			ASSERT(getPreResolverTop() == node);
[-] 			ASSERT (productionIndex < T::LaDfaFirst);
[+] 			ASSERT(productionIndex < T::LaDfaFirst);
[-] 			popPreResolver ();
[+] 			popPreResolver();
[-] 			popPrediction ();
[+] 			popPrediction();
[-] 			pushPrediction (productionIndex);
[+] 			pushPrediction(productionIndex);
[-] 		LaDfaResult laDfaResult = static_cast <T*> (this)->laDfa (
[+] 		LaDfaResult laDfaResult = static_cast<T*> (this)->laDfa(
[-] 		switch (laDfaResult)
[+] 		switch(laDfaResult)
[-] 				popPrediction ();
[+] 				popPrediction();
[-] 				pushPrediction (transition.m_productionIndex);
[+] 				pushPrediction(transition.m_productionIndex);
[-] 			pushPreResolver (node);
[+] 			pushPreResolver(node);
[-] 			pushPrediction (transition.m_resolverIndex);
[+] 			pushPrediction(transition.m_resolverIndex);
[-] 			ASSERT (laDfaResult == LaDfaResult_Fail);
[+] 			ASSERT(laDfaResult == LaDfaResult_Fail);
[-] 			if (m_resolverStack.isEmpty ()) // can't rollback so set error
[+] 			if (m_resolverStack.isEmpty()) // can't rollback so set error
[-] 				SymbolNode* symbol = getSymbolTop ();
[+] 				SymbolNode* symbol = getSymbolTop();
[-] 				ASSERT (symbol);
[+] 				ASSERT(symbol);
[-] 				axl::err::setFormatStringError (
[+] 				axl::err::setFormatStringError(
[-] 					m_currentToken.getName (),
[+] 					m_currentToken.getName(),
[-] 					static_cast <T*> (this)->getSymbolName (symbol->m_index)
[+] 					static_cast<T*> (this)->getSymbolName(symbol->m_index)
[-] 	rollbackResolver ()
[+] 	rollbackResolver()
[-] 		LaDfaNode* laDfaNode = getPreResolverTop ();
[+] 		LaDfaNode* laDfaNode = getPreResolverTop();
[-] 		ASSERT (laDfaNode);
[+] 		ASSERT(laDfaNode);
[-] 		ASSERT (laDfaNode->m_flags & LaDfaNodeFlag_PreResolver);
[+] 		ASSERT(laDfaNode->m_flags & LaDfaNodeFlag_PreResolver);
[-] 		while (!m_predictionStack.isEmpty ())
[+] 		while (!m_predictionStack.isEmpty())
[-] 			Node* node = getPredictionTop ();
[+] 			Node* node = getPredictionTop();
[-] 				ASSERT (getSymbolTop () == node);
[+] 				ASSERT(getSymbolTop() == node);
[-] 				popSymbol ();
[+] 				popSymbol();
[-] 			popPrediction ();
[+] 			popPrediction();
[-] 		ASSERT (getPredictionTop () == laDfaNode);
[+] 		ASSERT(getPredictionTop() == laDfaNode);
[-] 		popPreResolver ();
[+] 		popPreResolver();
[-] 			popPrediction ();
[+] 			popPrediction();
[-] 			pushPrediction (productionIndex);
[+] 			pushPrediction(productionIndex);
[-] 	createStdSymbolNode (size_t index)
[+] 	createStdSymbolNode(size_t index)
[-] 		SymbolNode* node = AXL_MEM_NEW (SymbolNode);
[+] 		SymbolNode* node = AXL_MEM_NEW(SymbolNode);
[-] 	createNode (size_t masterIndex)
[+] 	createNode(size_t masterIndex)
[-] 		ASSERT (masterIndex < T::TotalCount);
[+] 		ASSERT(masterIndex < T::TotalCount);
[-] 			node = AXL_MEM_NEW (TokenNode);
[+] 			node = AXL_MEM_NEW(TokenNode);
[-] 			SymbolNode* symbolNode = static_cast <T*> (this)->createSymbolNode (index);
[+] 			SymbolNode* symbolNode = static_cast<T*> (this)->createSymbolNode(index);
[-] 					m_ast.createBuffer ();
[+] 					m_ast.createBuffer();
[-] 				m_ast->add (symbolNode->m_astNode);
[+] 				m_ast->add(symbolNode->m_astNode);
[-] 			node = AXL_MEM_NEW (SymbolNode);
[+] 			node = AXL_MEM_NEW(SymbolNode);
[-] 			node = AXL_MEM_NEW (Node);
[+] 			node = AXL_MEM_NEW(Node);
[-] 			node = AXL_MEM_NEW (Node);
[+] 			node = AXL_MEM_NEW(Node);
[-] 			node = AXL_MEM_NEW (Node);
[+] 			node = AXL_MEM_NEW(Node);
[-] 			size_t* p = static_cast <T*> (this)->getBeacon (masterIndex - T::BeaconFirst);
[+] 			size_t* p = static_cast<T*> (this)->getBeacon(masterIndex - T::BeaconFirst);
[-] 			size_t slotIndex = p [0];
[+] 			size_t slotIndex = p[0];
[-] 			size_t targetIndex = p [1];
[+] 			size_t targetIndex = p[1];
[-] 			node = createNode (targetIndex);
[+] 			node = createNode(targetIndex);
[-] 			ASSERT (node->m_kind == NodeKind_Token || node->m_kind == NodeKind_Symbol);
[+] 			ASSERT(node->m_kind == NodeKind_Token || node->m_kind == NodeKind_Symbol);
[-] 			SymbolNode* symbolNode = getSymbolTop ();
[+] 			SymbolNode* symbolNode = getSymbolTop();
[-] 			ASSERT (symbolNode);
[+] 			ASSERT(symbolNode);
[-] 			symbolNode->m_locatorArray.ensureCountZeroConstruct (slotIndex + 1);
[+] 			symbolNode->m_locatorArray.ensureCountZeroConstruct(slotIndex + 1);
[-] 			symbolNode->m_locatorArray [slotIndex] = node;
[+] 			symbolNode->m_locatorArray[slotIndex] = node;
[-] 			symbolNode->m_locatorList.insertTail (node);
[+] 			symbolNode->m_locatorList.insertTail(node);
[-] 			ASSERT (masterIndex < T::LaDfaEnd);
[+] 			ASSERT(masterIndex < T::LaDfaEnd);
[-] 			node = AXL_MEM_NEW (LaDfaNode);
[+] 			node = AXL_MEM_NEW(LaDfaNode);
[-] 	getArgument ()
[+] 	getArgument()
[-] 		size_t count = m_predictionStack.getCount ();
[+] 		size_t count = m_predictionStack.getCount();
[-] 		Node* node = m_predictionStack [count - 2];
[+] 		Node* node = m_predictionStack[count - 2];
[-] 	pushPrediction (size_t masterIndex)
[+] 	pushPrediction(size_t masterIndex)
[-] 		Node* node = createNode (masterIndex);
[+] 		Node* node = createNode(masterIndex);
[-] 			m_nodeList.insertTail (node);
[+] 			m_nodeList.insertTail(node);
[-] 		m_predictionStack.append (node);
[+] 		m_predictionStack.append(node);
[-] 	popPrediction ()
[+] 	popPrediction()
[-] 		size_t count = m_predictionStack.getCount ();
[+] 		size_t count = m_predictionStack.getCount();
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		Node* node = m_predictionStack [count - 1];
[+] 		Node* node = m_predictionStack[count - 1];
[-] 			m_nodeList.erase (node);
[+] 			m_nodeList.erase(node);
[-] 		m_predictionStack.setCount (count - 1);
[+] 		m_predictionStack.setCount(count - 1);
[-] 	getAst (size_t index)
[+] 	getAst(size_t index)
[-] 		size_t count = m_symbolStack.getCount ();
[+] 		size_t count = m_symbolStack.getCount();
[-] 		return index < count ? m_symbolStack [count - index - 1]->m_astNode : NULL;
[+] 		return index < count ? m_symbolStack[count - index - 1]->m_astNode : NULL;
[-] 	getAstTop ()
[+] 	getAstTop()
[-] 		size_t count = m_symbolStack.getCount ();
[+] 		size_t count = m_symbolStack.getCount();
[-] 			SymbolNode* node = m_symbolStack [i];
[+] 			SymbolNode* node = m_symbolStack[i];
[-] 	pushSymbol (SymbolNode* node)
[+] 	pushSymbol(SymbolNode* node)
[-] 			AstNode* astTop = getAstTop ();
[+] 			AstNode* astTop = getAstTop();
[-] 				astTop->m_children.append (node->m_astNode);
[+] 				astTop->m_children.append(node->m_astNode);
[-] 		m_symbolStack.append (node);
[+] 		m_symbolStack.append(node);
[-] 		size_t count = m_symbolStack.getCount ();
[+] 		size_t count = m_symbolStack.getCount();
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		SymbolNode* node = m_symbolStack [count - 1];
[+] 		SymbolNode* node = m_symbolStack[count - 1];
[-] 		m_symbolStack.setCount (count - 1);
[+] 		m_symbolStack.setCount(count - 1);
[-] 	getPreResolverTop ()
[+] 	getPreResolverTop()
[-] 		size_t count = m_resolverStack.getCount ();
[+] 		size_t count = m_resolverStack.getCount();
[-] 		return count ? m_resolverStack [count - 1] : NULL;
[+] 		return count ? m_resolverStack[count - 1] : NULL;
[-] 	pushPreResolver (LaDfaNode* node)
[+] 	pushPreResolver(LaDfaNode* node)
[-] 		m_resolverStack.append (node);
[+] 		m_resolverStack.append(node);
[-] 	popPreResolver ()
[+] 	popPreResolver()
[-] 		size_t count = m_resolverStack.getCount ();
[+] 		size_t count = m_resolverStack.getCount();
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		LaDfaNode* node = m_resolverStack [count - 1];
[+] 		LaDfaNode* node = m_resolverStack[count - 1];
[-] 		m_resolverStack.setCount (count - 1);
[+] 		m_resolverStack.setCount(count - 1);
[-] 	getLocator (size_t index)
[+] 	getLocator(size_t index)
[-] 		SymbolNode* symbolNode = getSymbolTop ();
[+] 		SymbolNode* symbolNode = getSymbolTop();
[-] 		size_t count = symbolNode->m_locatorArray.getCount ();
[+] 		size_t count = symbolNode->m_locatorArray.getCount();
[-] 		Node* node = symbolNode->m_locatorArray [index];
[+] 		Node* node = symbolNode->m_locatorArray[index];
[-] 	getAstLocator (size_t index)
[+] 	getAstLocator(size_t index)
[-] 		Node* node = getLocator (index);
[+] 		Node* node = getLocator(index);
[-] 		return node && node->m_kind == NodeKind_Symbol ? ((SymbolNode*) node)->m_astNode : NULL;
[+] 		return node && node->m_kind == NodeKind_Symbol ? ((SymbolNode*)node)->m_astNode : NULL;
[-] 	getTokenLocator (size_t index)
[+] 	getTokenLocator(size_t index)
[-] 		Node* node = getLocator (index);
[+] 		Node* node = getLocator(index);
[-] 		return node && node->m_kind == NodeKind_Token ? &((TokenNode*) node)->m_token : NULL;
[+] 		return node && node->m_kind == NodeKind_Token ? &((TokenNode*)node)->m_token : NULL;
----------------------
27/02/2019 18:01:54 - C:\Projects\repos\ioninja\graco\samples\graco_sample_01_calc\Lexer.cpp
----------------------
[-] Lexer::createStringToken (
[+] Lexer::createStringToken(
[-] 	Token* token = createToken (tokenKind);
[+] 	Token* token = createToken(tokenKind);
[-] 	ASSERT (token->m_pos.m_length >= left + right);
[+] 	ASSERT(token->m_pos.m_length >= left + right);
[-] 	token->m_data.m_string = sl::StringRef (ts + left, length);
[+] 	token->m_data.m_string = sl::StringRef(ts + left, length);
[-] Lexer::createCharToken (int tokenKind)
[+] Lexer::createCharToken(int tokenKind)
[-] 	Token* token = createToken (tokenKind);
[+] 	Token* token = createToken(tokenKind);
[-] 	ASSERT (token->m_pos.m_length >= 2);
[+] 	ASSERT(token->m_pos.m_length >= 2);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	enc::EscapeEncoding::decode (&string, sl::StringRef (ts + 1, token->m_pos.m_length - 2));
[+] 	enc::EscapeEncoding::decode(&string, sl::StringRef(ts + 1, token->m_pos.m_length - 2));
[-] 	token->m_data.m_integer = string [0];
[+] 	token->m_data.m_integer = string[0];
[-] Lexer::createIntegerToken (
[+] Lexer::createIntegerToken(
[-] 	Token* token = createToken (TokenKind_Integer);
[+] 	Token* token = createToken(TokenKind_Integer);
[-] 	token->m_data.m_int64_u = _strtoui64 (ts + left, NULL, radix);
[+] 	token->m_data.m_int64_u = _strtoui64(ts + left, NULL, radix);
[-] Lexer::createFpToken ()
[+] Lexer::createFpToken()
[-] 	Token* token = createToken (TokenKind_Fp);
[+] 	Token* token = createToken(TokenKind_Fp);
[-] 	token->m_data.m_double = strtod (ts, NULL);
[+] 	token->m_data.m_double = strtod(ts, NULL);
----------------------
27/02/2019 18:01:54 - C:\Projects\repos\ioninja\graco\samples\graco_sample_01_calc\main.cpp
----------------------
[-] parse (const sl::StringRef& p)
[+] parse(const sl::StringRef& p)
[-] 	lexer.create ("my-source", p);
[+] 	lexer.create("my-source", p);
[-] 	parser.create (Parser::StartSymbol);
[+] 	parser.create(Parser::StartSymbol);
[-] 		const Token* token = lexer.getToken ();
[+] 		const Token* token = lexer.getToken();
[-] 			err::setFormatStringError ("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[+] 			err::setFormatStringError("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[-] 		result = parser.parseToken (token);
[+] 		result = parser.parseToken(token);
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	g::getModule ()->setTag ("graco_test_cpp");
[+] 	g::getModule()->setTag("graco_test_cpp");
[-] 	bool result = parse (
[+] 	bool result = parse(
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
----------------------
27/02/2019 18:01:54 - C:\Projects\repos\ioninja\graco\samples\graco_sample_01_calc\Parser.cpp
----------------------
[-] Parser::createVariable (
[+] Parser::createVariable(
[-] 	sl::StringHashTableIterator <Variable*> it = m_variableMap.visit (name);
[+] 	sl::StringHashTableIterator<Variable*> it = m_variableMap.visit(name);
[-] 		err::setFormatStringError ("'%s': identifier redefinition", name.sz ());
[+] 		err::setFormatStringError("'%s': identifier redefinition", name.sz ());
[-] 	Variable* variable = AXL_MEM_NEW (Variable);
[+] 	Variable* variable = AXL_MEM_NEW(Variable);
[-] 	m_variableList.insertTail (variable);
[+] 	m_variableList.insertTail(variable);
[-] Parser::lookupIdentifier (
[+] Parser::lookupIdentifier(
[-] 	sl::StringHashTableIterator <Variable*> it = m_variableMap.find (name);
[+] 	sl::StringHashTableIterator<Variable*> it = m_variableMap.find(name);
[-] 		err::setFormatStringError ("'%d': undeclared identifier", name.sz ());
[+] 		err::setFormatStringError("'%d': undeclared identifier", name.sz ());
[-] Parser::assertionCheck (
[+] Parser::assertionCheck(
[-] 	if (!value.isTrue ())
[+] 	if (!value.isTrue())
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			sl::StringRef (openPos.m_p, closePos.m_p + closePos.m_length - openPos.m_p).sz ()
[+] 			sl::StringRef(openPos.m_p, closePos.m_p + closePos.m_length - openPos.m_p).sz()
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\samples\graco_sample_01_calc\Value.cpp
----------------------
[-] getUnOpKindString (UnOpKind opKind)
[+] getUnOpKindString(UnOpKind opKind)
[-] 	const char* stringTable [UnOpKind__Count] =
[+] 	const char* stringTable[UnOpKind__Count] =
[-] 	ASSERT ((size_t) opKind < countof (stringTable));
[+] 	ASSERT((size_t)opKind < countof(stringTable));
[-] 	return stringTable [(size_t) opKind];
[+] 	return stringTable[(size_t)opKind];
[-] getBinOpKindString (BinOpKind opKind)
[+] getBinOpKindString(BinOpKind opKind)
[-] 	const char* stringTable [BinOpKind__Count] =
[+] 	const char* stringTable[BinOpKind__Count] =
[-] 	ASSERT ((size_t) opKind < countof (stringTable));
[+] 	ASSERT((size_t)opKind < countof(stringTable));
[-] 	return stringTable [(size_t) opKind];
[+] 	return stringTable[(size_t)opKind];
[-] getRelOpKindString (RelOpKind opKind)
[+] getRelOpKindString(RelOpKind opKind)
[-] 	const char* stringTable [RelOpKind__Count] =
[+] 	const char* stringTable[RelOpKind__Count] =
[-] 	ASSERT ((size_t) opKind < countof (stringTable));
[+] 	ASSERT((size_t)opKind < countof(stringTable));
[-] 	return stringTable [(size_t) opKind];
[+] 	return stringTable[(size_t)opKind];
[-] unOpFunc (Type value)
[+] unOpFunc(Type value)
[-] 	return Functor () (value);
[+] 	return Functor() (value);
[-] binOpFunc (
[+] binOpFunc(
[-] 	return Functor () (value1, value2);
[+] 	return Functor() (value1, value2);
[-] relOpFunc (
[+] relOpFunc(
[-] 	return Functor () (value1, value2);
[+] 	return Functor() (value1, value2);
[-] Value::Value ()
[+] Value::Value()
[-] Value::Value (int integer)
[+] Value::Value(int integer)
[-] Value::Value (double fp)
[+] Value::Value(double fp)
[-] Value::Value (Variable* variable)
[+] Value::Value(Variable* variable)
[-] Value::isTrue () const
[+] Value::isTrue() const
[-] Value::lvalueCheck () const
[+] Value::lvalueCheck() const
[-] 		err::setError ("not l-value");
[+] 		err::setError("not l-value");
[-] 		err::setFormatStringError ("'%s' is constant", m_variable->m_name.sz ());
[+] 		err::setFormatStringError("'%s' is constant", m_variable->m_name.sz ());
[-] Value::getString () const
[+] Value::getString() const
[-] 	switch (m_type)
[+] 	switch(m_type)
[-] 		return sl::formatString ("%d (0x%x)", m_integer, m_integer);
[+] 		return sl::formatString("%d (0x%x)", m_integer, m_integer);
[-] 		return sl::formatString ("%.2f (%e)", m_fp, m_fp);
[+] 		return sl::formatString("%.2f (%e)", m_fp, m_fp);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Value::unaryOperator (UnOpKind opKind)
[+] Value::unaryOperator(UnOpKind opKind)
[-] 	static Operator operatorTable [UnOpKind__Count] =
[+] 	static Operator operatorTable[UnOpKind__Count] =
[-] 		{ unOpFunc <int, sl::Minus <int> >, unOpFunc <double, sl::Minus <double> > }, // UnOpKind_Minus,
[+] 		{ unOpFunc<int, sl::Minus<int> >, unOpFunc<double, sl::Minus<double> > }, // UnOpKind_Minus,
[-] 		{ unOpFunc <int, sl::Not <int> >,   NULL }                                    // UnOpKind_BitwiseNot,
[+] 		{ unOpFunc<int, sl::Not<int> >,   NULL }                                    // UnOpKind_BitwiseNot,
[-] 	ASSERT (opKind < countof (operatorTable));
[+] 	ASSERT(opKind < countof(operatorTable));
[-] 	Operator* op = &operatorTable [opKind];
[+] 	Operator* op = &operatorTable[opKind];
[-] 	switch (m_type)
[+] 	switch(m_type)
[-] 		err::setError ("cannot apply operators to 'null' values");
[+] 		err::setError("cannot apply operators to 'null' values");
[-] 		m_integer = op->m_intFunc (m_integer);
[+] 		m_integer = op->m_intFunc(m_integer);
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				getUnOpKindString (opKind)
[+] 				getUnOpKindString(opKind)
[-] 		m_fp = op->m_fpFunc (m_fp);
[+] 		m_fp = op->m_fpFunc(m_fp);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Value::binaryOperator (
[+] Value::binaryOperator(
[-] 	static Operator operatorTable [BinOpKind__Count] =
[+] 	static Operator operatorTable[BinOpKind__Count] =
[-] 		{ binOpFunc <int, sl::Add <int> >, binOpFunc <double, sl::Add <double> > }, // BinOpKind_Add,
[+] 		{ binOpFunc<int, sl::Add<int> >, binOpFunc<double, sl::Add<double> > }, // BinOpKind_Add,
[-] 		{ binOpFunc <int, sl::Sub <int> >, binOpFunc <double, sl::Sub <double> > }, // BinOpKind_Sub,
[+] 		{ binOpFunc<int, sl::Sub<int> >, binOpFunc<double, sl::Sub<double> > }, // BinOpKind_Sub,
[-] 		{ binOpFunc <int, sl::Mul <int> >, binOpFunc <double, sl::Mul <double> > }, // BinOpKind_Mul,
[+] 		{ binOpFunc<int, sl::Mul<int> >, binOpFunc<double, sl::Mul<double> > }, // BinOpKind_Mul,
[-] 		{ binOpFunc <int, sl::Div <int> >, binOpFunc <double, sl::Div <double> > }, // BinOpKind_Div,
[+] 		{ binOpFunc<int, sl::Div<int> >, binOpFunc<double, sl::Div<double> > }, // BinOpKind_Div,
[-] 		{ binOpFunc <int, sl::Mod <int> >, NULL },                                  // BinOpKind_Mod,
[+] 		{ binOpFunc<int, sl::Mod<int> >, NULL },                                  // BinOpKind_Mod,
[-] 		{ binOpFunc <int, sl::Shl <int> >, NULL },                                  // BinOpKind_Shl,
[+] 		{ binOpFunc<int, sl::Shl<int> >, NULL },                                  // BinOpKind_Shl,
[-] 		{ binOpFunc <int, sl::Shr <int> >, NULL },                                  // BinOpKind_Shr,
[+] 		{ binOpFunc<int, sl::Shr<int> >, NULL },                                  // BinOpKind_Shr,
[-] 		{ binOpFunc <int, sl::And <int> >, NULL },                                  // BinOpKind_And,
[+] 		{ binOpFunc<int, sl::And<int> >, NULL },                                  // BinOpKind_And,
[-] 		{ binOpFunc <int, sl::Xor <int> >, NULL },                                  // BinOpKind_Xor,
[+] 		{ binOpFunc<int, sl::Xor<int> >, NULL },                                  // BinOpKind_Xor,
[-] 		{ binOpFunc <int, sl::Or  <int> >, NULL },                                  // BinOpKind_Or,
[+] 		{ binOpFunc<int, sl::Or  <int> >, NULL },                                  // BinOpKind_Or,
[-] 		err::setError ("cannot apply operators to 'null' values");
[+] 		err::setError("cannot apply operators to 'null' values");
[-] 	ASSERT (opKind < countof (operatorTable));
[+] 	ASSERT(opKind < countof(operatorTable));
[-] 	Operator* op = &operatorTable [opKind];
[+] 	Operator* op = &operatorTable[opKind];
[-] 	Type type = AXL_MAX (m_type, value.m_type);
[+] 	Type type = AXL_MAX(m_type, value.m_type);
[-] 	switch (type)
[+] 	switch(type)
[-] 		m_integer = op->m_intFunc (m_integer, value.m_integer);
[+] 		m_integer = op->m_intFunc(m_integer, value.m_integer);
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				getBinOpKindString (opKind)
[+] 				getBinOpKindString(opKind)
[-] 		m_fp = op->m_fpFunc (getFp (), value.getFp ());
[+] 		m_fp = op->m_fpFunc(getFp(), value.getFp());
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Value::relationalOperator (
[+] Value::relationalOperator(
[-] 	static Operator operatorTable [BinOpKind__Count] =
[+] 	static Operator operatorTable[BinOpKind__Count] =
[-] 		{ relOpFunc <int, sl::Eq <int> >, relOpFunc <double, sl::Eq <double> > }, // RelOpKind_Eq,
[+] 		{ relOpFunc<int, sl::Eq<int> >, relOpFunc<double, sl::Eq<double> > }, // RelOpKind_Eq,
[-] 		{ relOpFunc <int, sl::Ne <int> >, relOpFunc <double, sl::Ne <double> > }, // RelOpKind_Ne,
[+] 		{ relOpFunc<int, sl::Ne<int> >, relOpFunc<double, sl::Ne<double> > }, // RelOpKind_Ne,
[-] 		{ relOpFunc <int, sl::Lt <int> >, relOpFunc <double, sl::Lt <double> > }, // RelOpKind_Lt,
[+] 		{ relOpFunc<int, sl::Lt<int> >, relOpFunc<double, sl::Lt<double> > }, // RelOpKind_Lt,
[-] 		{ relOpFunc <int, sl::Gt <int> >, relOpFunc <double, sl::Gt <double> > }, // RelOpKind_Gt,
[+] 		{ relOpFunc<int, sl::Gt<int> >, relOpFunc<double, sl::Gt<double> > }, // RelOpKind_Gt,
[-] 		{ relOpFunc <int, sl::Le <int> >, relOpFunc <double, sl::Le <double> > }, // RelOpKind_Le,
[+] 		{ relOpFunc<int, sl::Le<int> >, relOpFunc<double, sl::Le<double> > }, // RelOpKind_Le,
[-] 		{ relOpFunc <int, sl::Ge <int> >, relOpFunc <double, sl::Ge <double> > }, // RelOpKind_Ge,
[+] 		{ relOpFunc<int, sl::Ge<int> >, relOpFunc<double, sl::Ge<double> > }, // RelOpKind_Ge,
[-] 		err::setError ("cannot apply operators to 'null' values");
[+] 		err::setError("cannot apply operators to 'null' values");
[-] 	ASSERT ((size_t) opKind < countof (operatorTable));
[+] 	ASSERT((size_t)opKind < countof(operatorTable));
[-] 	Operator* op = &operatorTable [opKind];
[+] 	Operator* op = &operatorTable[opKind];
[-] 	Type type = AXL_MAX (m_type, value.m_type);
[+] 	Type type = AXL_MAX(m_type, value.m_type);
[-] 	switch (type)
[+] 	switch(type)
[-] 		m_integer = op->m_intFunc (m_integer, value.m_integer);
[+] 		m_integer = op->m_intFunc(m_integer, value.m_integer);
[-] 		m_integer = op->m_fpFunc (getFp (), value.getFp ());
[+] 		m_integer = op->m_fpFunc(getFp(), value.getFp());
[-] 		ASSERT (false);
[+] 		ASSERT(false);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\samples\graco_sample_01_calc\Lexer.h
----------------------
[-] AXL_LEX_BEGIN_TOKEN_NAME_MAP (TokenName)
[+] AXL_LEX_BEGIN_TOKEN_NAME_MAP(TokenName)
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Eof,        "eof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Eof,        "eof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Error,      "error")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Error,      "error")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Identifier, "identifier")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Identifier, "identifier")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Integer,    "integer-constant")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Integer,    "integer-constant")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Fp,         "floating-point-constant")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Fp,         "floating-point-constant")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Inc,        "++")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Inc,        "++")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Dec,        "--")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Dec,        "--")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_MulAssign,  "*=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_MulAssign,  "*=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_DivAssign,  "/=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_DivAssign,  "/=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ModAssign,  "%=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ModAssign,  "%=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_AddAssign,  "+=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_AddAssign,  "+=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_SubAssign,  "-=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_SubAssign,  "-=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ShlAssign,  "<<=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ShlAssign,  "<<=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_ShrAssign,  ">>=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_ShrAssign,  ">>=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_AndAssign,  "&=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_AndAssign,  "&=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_XorAssign,  "^=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_XorAssign,  "^=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OrAssign,   "|=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OrAssign,   "|=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Shl,        "<<")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Shl,        "<<")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Shr,        ">>")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Shr,        ">>")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Le,         "<=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Le,         "<=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Ge,         ">=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Ge,         ">=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Eq,         "==")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Eq,         "==")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Ne,         "!=")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Ne,         "!=")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_LogicalAnd, "&&")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_LogicalAnd, "&&")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_LogicalOr,  "||")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_LogicalOr,  "||")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Var,    "var")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Var,    "var")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Const,  "const")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Const,  "const")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Null,   "null")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Null,   "null")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Assert, "assert")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Assert, "assert")
[-] AXL_LEX_END_TOKEN_NAME_MAP ();
[+] AXL_LEX_END_TOKEN_NAME_MAP();
[-] typedef lex::RagelToken <TokenKind, TokenName, lex::StdTokenData> Token;
[+] typedef lex::RagelToken<TokenKind, TokenName, lex::StdTokenData> Token;
[-] class Lexer: public lex::RagelLexer <Lexer, Token>
[+] class Lexer: public lex::RagelLexer<Lexer, Token>
[-] 	friend class lex::RagelLexer <Lexer, Token>;
[+] 	friend class lex::RagelLexer<Lexer, Token>;
[-] 	createStringToken (
[+] 	createStringToken(
[-] 	createCharToken (int tokenKind);
[+] 	createCharToken(int tokenKind);
[-] 	createIntegerToken (
[+] 	createIntegerToken(
[-] 	createFpToken ();
[+] 	createFpToken();
[-] 	init ();
[+] 	init();
[-] 	exec ();
[+] 	exec();
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\samples\graco_sample_01_calc\Value.h
----------------------
[-] getUnOpKindString (UnOpKind opKind);
[+] getUnOpKindString(UnOpKind opKind);
[-] getBinOpKindString (BinOpKind opKind);
[+] getBinOpKindString(BinOpKind opKind);
[-] getRelOpKindString (RelOpKind opKind);
[+] getRelOpKindString(RelOpKind opKind);
[-] 	Value ();
[+] 	Value();
[-] 	Value (int integer);
[+] 	Value(int integer);
[-] 	Value (double fp);
[+] 	Value(double fp);
[-] 	Value (Variable* variable);
[+] 	Value(Variable* variable);
[-] 	lvalueCheck () const;
[+] 	lvalueCheck() const;
[-] 	isTrue () const;
[+] 	isTrue() const;
[-] 	getFp () const
[+] 	getFp() const
[-] 		return m_type == Type_Int ? (double) m_integer : m_fp;
[+] 		return m_type == Type_Int ? (double)m_integer : m_fp;
[-] 	getString () const;
[+] 	getString() const;
[-] 	unaryOperator (UnOpKind opKind);
[+] 	unaryOperator(UnOpKind opKind);
[-] 	binaryOperator (
[+] 	binaryOperator(
[-] 	relationalOperator (
[+] 	relationalOperator(
[-] 	Variable ()
[+] 	Variable()
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\ClassMgr.cpp
----------------------
[-] Class::luaExport (lua::LuaState* luaState)
[+] Class::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable (0, 2);
[+] 	luaState->createTable(0, 2);
[-] 	luaState->setMemberString ("Name", m_name);
[+] 	luaState->setMemberString("Name", m_name);
[-] 		luaState->setMemberString ("BaseClass", m_baseClass->m_name);
[+] 		luaState->setMemberString("BaseClass", m_baseClass->m_name);
[-] 	luaState->setMemberString ("Members", m_members);
[+] 	luaState->setMemberString("Members", m_members);
[-] 	luaState->createTable (0, 3);
[+] 	luaState->createTable(0, 3);
[-] 	luaState->setMemberString ("FilePath", m_srcPos.m_filePath);
[+] 	luaState->setMemberString("FilePath", m_srcPos.m_filePath);
[-] 	luaState->setMemberInteger ("Line", m_srcPos.m_line);
[+] 	luaState->setMemberInteger("Line", m_srcPos.m_line);
[-] 	luaState->setMemberInteger ("Col", m_srcPos.m_col);
[+] 	luaState->setMemberInteger("Col", m_srcPos.m_col);
[-] 	luaState->setMember ("SrcPos");
[+] 	luaState->setMember("SrcPos");
[-] ClassMgr::getClass (const sl::StringRef& name)
[+] ClassMgr::getClass(const sl::StringRef& name)
[-] 	sl::StringHashTableIterator <Class*> it = m_classMap.visit (name);
[+] 	sl::StringHashTableIterator<Class*> it = m_classMap.visit(name);
[-] 	Class* cls = AXL_MEM_NEW (Class);
[+] 	Class* cls = AXL_MEM_NEW(Class);
[-] 	m_classList.insertTail (cls);
[+] 	m_classList.insertTail(cls);
[-] ClassMgr::createUnnamedClass ()
[+] ClassMgr::createUnnamedClass()
[-] 	Class* cls = AXL_MEM_NEW (Class);
[+] 	Class* cls = AXL_MEM_NEW(Class);
[-] 	cls->m_name.format ("_cls%d", m_classList.getCount () + 1);
[+] 	cls->m_name.format("_cls%d", m_classList.getCount () + 1);
[-] 	m_classList.insertTail (cls); // don't add to class map
[+] 	m_classList.insertTail(cls); // don't add to class map
[-] ClassMgr::deleteClass (Class* cls)
[+] ClassMgr::deleteClass(Class* cls)
[-] 		m_classMap.eraseKey (cls->m_name);
[+] 		m_classMap.eraseKey(cls->m_name);
[-] 	m_classList.erase (cls);
[+] 	m_classList.erase(cls);
[-] ClassMgr::verify ()
[+] ClassMgr::verify()
[-] 	sl::Iterator <Class> it = m_classList.getHead ();
[+] 	sl::Iterator<Class> it = m_classList.getHead();
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				cls->m_name.sz ()
[+] 				cls->m_name.sz()
[-] ClassMgr::deleteUnusedClasses ()
[+] ClassMgr::deleteUnusedClasses()
[-] 	sl::Iterator <Class> it = m_classList.getHead ();
[+] 	sl::Iterator<Class> it = m_classList.getHead();
[-] 			deleteClass (cls);
[+] 			deleteClass(cls);
[-] ClassMgr::deleteUnreachableClasses ()
[+] ClassMgr::deleteUnreachableClasses()
[-] 	sl::Iterator <Class> it = m_classList.getHead ();
[+] 	sl::Iterator<Class> it = m_classList.getHead();
[-] 			deleteClass (cls);
[+] 			deleteClass(cls);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\CmdLine.cpp
----------------------
[-] CmdLine::CmdLine ()
[+] CmdLine::CmdLine()
[-] CmdLineParser::onValue (const sl::StringRef& value)
[+] CmdLineParser::onValue(const sl::StringRef& value)
[-] CmdLineParser::onSwitch (
[+] CmdLineParser::onSwitch(
[-] 	switch (switchKind)
[+] 	switch(switchKind)
[-] 		m_cmdLine->m_lookaheadLimit = atoi (value.sz ());
[+] 		m_cmdLine->m_lookaheadLimit = atoi(value.sz());
[-] 		m_cmdLine->m_conflictDepthLimit = atoi (value.sz ());
[+] 		m_cmdLine->m_conflictDepthLimit = atoi(value.sz());
[-] 		m_cmdLine->m_outputFileNameList.insertTail (value);
[+] 		m_cmdLine->m_outputFileNameList.insertTail(value);
[-] 		m_cmdLine->m_frameFileNameList.insertTail (value);
[+] 		m_cmdLine->m_frameFileNameList.insertTail(value);
[-] 		m_cmdLine->m_frameDirList.insertTail (value);
[+] 		m_cmdLine->m_frameDirList.insertTail(value);
[-] 		m_cmdLine->m_importDirList.insertTail (value);
[+] 		m_cmdLine->m_importDirList.insertTail(value);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] CmdLineParser::finalize ()
[+] CmdLineParser::finalize()
[-] 	if (m_cmdLine->m_outputFileNameList.getCount () !=
[+] 	if (m_cmdLine->m_outputFileNameList.getCount() !=
[-] 		m_cmdLine->m_frameFileNameList.getCount ())
[+] 		m_cmdLine->m_frameFileNameList.getCount())
[-] 		err::setError ("output-file-count vs frame-file-count mismatch\n");
[+] 		err::setError("output-file-count vs frame-file-count mismatch\n");
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\DefineMgr.cpp
----------------------
[-] DefineMgr::getDefine (const sl::StringRef& name)
[+] DefineMgr::getDefine(const sl::StringRef& name)
[-] 	sl::StringHashTableIterator <Define*> it = m_defineMap.visit (name);
[+] 	sl::StringHashTableIterator<Define*> it = m_defineMap.visit(name);
[-] 	Define* define = AXL_MEM_NEW (Define);
[+] 	Define* define = AXL_MEM_NEW(Define);
[-] 	m_defineList.insertTail (define);
[+] 	m_defineList.insertTail(define);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\Generator.cpp
----------------------
[-] Generator::prepare (Module* module)
[+] Generator::prepare(Module* module)
[-] 	m_stringTemplate.create ();
[+] 	m_stringTemplate.create();
[-] 	module->luaExport (&m_stringTemplate.m_luaState);
[+] 	module->luaExport(&m_stringTemplate.m_luaState);
[-] Generator::generate (
[+] Generator::generate(
[-] 		frameFilePath = io::findFilePath (frameFileName, &m_cmdLine->m_frameDirList);
[+] 		frameFilePath = io::findFilePath(frameFileName, &m_cmdLine->m_frameDirList);
[-] 		if (frameFilePath.isEmpty ())
[+] 		if (frameFilePath.isEmpty())
[-] 			err::setFormatStringError ("frame file '%s' not found", frameFileName.sz ());
[+] 			err::setFormatStringError("frame file '%s' not found", frameFileName.sz ());
[-] 	result = frameFile.open (frameFilePath, io::FileFlag_ReadOnly);
[+] 	result = frameFile.open(frameFilePath, io::FileFlag_ReadOnly);
[-] 	size_t size = (size_t) frameFile.getSize ();
[+] 	size_t size = (size_t)frameFile.getSize();
[-] 	char* p = (char*) frameFile.view (0, size);
[+] 	char* p = (char*)frameFile.view(0, size);
[-] 	m_buffer.reserve (size);
[+] 	m_buffer.reserve(size);
[-] 	sl::String targetFilePath = io::getFullFilePath (fileName);
[+] 	sl::String targetFilePath = io::getFullFilePath(fileName);
[-] 	sl::String frameDir = io::getDir (frameFilePath);
[+] 	sl::String frameDir = io::getDir(frameFilePath);
[-] 	m_stringTemplate.m_luaState.setGlobalString ("TargetFilePath", targetFilePath);
[+] 	m_stringTemplate.m_luaState.setGlobalString("TargetFilePath", targetFilePath);
[-] 	m_stringTemplate.m_luaState.setGlobalString ("FrameFilePath", frameFilePath);
[+] 	m_stringTemplate.m_luaState.setGlobalString("FrameFilePath", frameFilePath);
[-] 	m_stringTemplate.m_luaState.setGlobalString ("FrameDir", frameDir);
[+] 	m_stringTemplate.m_luaState.setGlobalString("FrameDir", frameDir);
[-] 	m_stringTemplate.m_luaState.setGlobalBoolean ("NoPpLine", (m_cmdLine->m_flags & CmdLineFlag_NoPpLine) != 0);
[+] 	m_stringTemplate.m_luaState.setGlobalBoolean("NoPpLine", (m_cmdLine->m_flags & CmdLineFlag_NoPpLine) != 0);
[-] 	result = m_stringTemplate.process (&m_buffer, frameFilePath, sl::StringRef (p, size));
[+] 	result = m_stringTemplate.process(&m_buffer, frameFilePath, sl::StringRef(p, size));
[-] 	result = targetFile.open (targetFilePath);
[+] 	result = targetFile.open(targetFilePath);
[-] 	size = m_buffer.getLength ();
[+] 	size = m_buffer.getLength();
[-] 	result = targetFile.write (m_buffer, size) != -1;
[+] 	result = targetFile.write(m_buffer, size) != -1;
[-] 	targetFile.setSize (size);
[+] 	targetFile.setSize(size);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\LaDfaBuilder.cpp
----------------------
[-] LaDfaThread::LaDfaThread ()
[+] LaDfaThread::LaDfaThread()
[-] LaDfaState::LaDfaState ()
[+] LaDfaState::LaDfaState()
[-] LaDfaState::createThread (LaDfaThread* src)
[+] LaDfaState::createThread(LaDfaThread* src)
[-] 	LaDfaThread* thread = AXL_MEM_NEW (LaDfaThread);
[+] 	LaDfaThread* thread = AXL_MEM_NEW(LaDfaThread);
[-] 		ASSERT (!src->m_resolver);
[+] 		ASSERT(!src->m_resolver);
[-] 	m_activeThreadList.insertTail (thread);
[+] 	m_activeThreadList.insertTail(thread);
[-] LaDfaState::calcResolved ()
[+] LaDfaState::calcResolved()
[-] 	sl::Iterator <LaDfaThread> thread;
[+] 	sl::Iterator<LaDfaThread> thread;
[-] 	if (m_activeThreadList.isEmpty ())
[+] 	if (m_activeThreadList.isEmpty())
[-] 	thread = m_activeThreadList.getHead ();
[+] 	thread = m_activeThreadList.getHead();
[-] 	thread = m_completeThreadList.getHead ();
[+] 	thread = m_completeThreadList.getHead();
[-] LaDfaState::getResolvedProduction ()
[+] LaDfaState::getResolvedProduction()
[-] 	LaDfaThread* activeThread = *m_activeThreadList.getHead ();
[+] 	LaDfaThread* activeThread = *m_activeThreadList.getHead();
[-] 	LaDfaThread* completeThread = *m_completeThreadList.getHead ();
[+] 	LaDfaThread* completeThread = *m_completeThreadList.getHead();
[-] 	LaDfaThread* epsilonThread = *m_epsilonThreadList.getHead ();
[+] 	LaDfaThread* epsilonThread = *m_epsilonThreadList.getHead();
[-] 	if (isAnyTokenIgnored ())
[+] 	if (isAnyTokenIgnored())
[-] LaDfaState::getDefaultProduction ()
[+] LaDfaState::getDefaultProduction()
[-] 	LaDfaThread* completeThread = *m_completeThreadList.getHead ();
[+] 	LaDfaThread* completeThread = *m_completeThreadList.getHead();
[-] 	LaDfaThread* epsilonThread = *m_epsilonThreadList.getHead ();
[+] 	LaDfaThread* epsilonThread = *m_epsilonThreadList.getHead();
[-] 		m_fromState ? m_fromState->getDefaultProduction () : NULL;
[+] 		m_fromState ? m_fromState->getDefaultProduction() : NULL;
[-] LaDfaBuilder::LaDfaBuilder (
[+] LaDfaBuilder::LaDfaBuilder(
[-] 	sl::Array <Node*>* parseTable,
[+] 	sl::Array<Node*>* parseTable,
[-] cmpResolverThreadPriority (
[+] cmpResolverThreadPriority(
[-] LaDfaBuilder::build (
[+] LaDfaBuilder::build(
[-] 	ASSERT (conflict->m_kind == NodeKind_Conflict);
[+] 	ASSERT(conflict->m_kind == NodeKind_Conflict);
[-] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount ();
[+] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount();
[-] 	m_stateList.clear ();
[+] 	m_stateList.clear();
[-] 	LaDfaState* state0 = createState ();
[+] 	LaDfaState* state0 = createState();
[-] 	state0->m_dfaNode = m_nodeMgr->createLaDfaNode ();
[+] 	state0->m_dfaNode = m_nodeMgr->createLaDfaNode();
[-] 	size_t count = conflict->m_productionArray.getCount ();
[+] 	size_t count = conflict->m_productionArray.getCount();
[-] 		Node* production = conflict->m_productionArray [i];
[+] 		Node* production = conflict->m_productionArray[i];
[-] 		LaDfaThread* thread = state0->createThread ();
[+] 		LaDfaThread* thread = state0->createThread();
[-] 			SymbolNode* symbolNode = (SymbolNode*) production;
[+] 			SymbolNode* symbolNode = (SymbolNode*)production;
[-] 				ASSERT (symbolNode->m_productionArray.getCount () == 1);
[+] 				ASSERT(symbolNode->m_productionArray.getCount() == 1);
[-] 				thread->m_production = symbolNode->m_productionArray [0]; // adjust root production
[+] 				thread->m_production = symbolNode->m_productionArray[0]; // adjust root production
[-] 			thread->m_stack.append (production);
[+] 			thread->m_stack.append(production);
[-] 	bool result = transition (&state1, state0, conflict->m_token);
[+] 	bool result = transition(&state1, state0, conflict->m_token);
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			conflict->m_symbol->m_name.sz (),
[+] 			conflict->m_symbol->m_name.sz(),
[-] 			conflict->m_token->m_name.sz ()
[+] 			conflict->m_token->m_name.sz()
[-] 		lex::pushSrcPosError (conflict->m_symbol->m_srcPos);
[+] 		lex::pushSrcPosError(conflict->m_symbol->m_srcPos);
[-] 	if (!state1->isResolved ())
[+] 	if (!state1->isResolved())
[-] 		sl::Array <LaDfaState*> stateArray;
[+] 		sl::Array<LaDfaState*> stateArray;
[-] 		stateArray.append (state1);
[+] 		stateArray.append(state1);
[-] 		while (!stateArray.isEmpty () && lookahead < m_lookeaheadLimit)
[+] 		while (!stateArray.isEmpty() && lookahead < m_lookeaheadLimit)
[-] 			sl::Array <LaDfaState*> nextStateArray;
[+] 			sl::Array<LaDfaState*> nextStateArray;
[-] 			size_t stateCount = stateArray.getCount ();
[+] 			size_t stateCount = stateArray.getCount();
[-] 				LaDfaState* state = stateArray [j];
[+] 				LaDfaState* state = stateArray[j];
[-] 					SymbolNode* token = m_nodeMgr->m_tokenArray [k];
[+] 					SymbolNode* token = m_nodeMgr->m_tokenArray[k];
[-] 					result = transition (&newState, state, token);
[+] 					result = transition(&newState, state, token);
[-] 						err::setFormatStringError (
[+] 						err::setFormatStringError(
[-] 							conflict->m_symbol->m_name.sz (),
[+] 							conflict->m_symbol->m_name.sz(),
[-] 							conflict->m_token->m_name.sz ()
[+] 							conflict->m_token->m_name.sz()
[-] 						lex::pushSrcPosError (conflict->m_symbol->m_srcPos);
[+] 						lex::pushSrcPosError(conflict->m_symbol->m_srcPos);
[-] 					if (newState && !newState->isResolved ())
[+] 					if (newState && !newState->isResolved())
[-] 						nextStateArray.append (newState);
[+] 						nextStateArray.append(newState);
[-] 		if (!stateArray.isEmpty ())
[+] 		if (!stateArray.isEmpty())
[-] 			size_t count = stateArray.getCount ();
[+] 			size_t count = stateArray.getCount();
[-] 			LaDfaState* state = stateArray [0];
[+] 			LaDfaState* state = stateArray[0];
[-] 			sl::BoxList <sl::String> tokenNameList;
[+] 			sl::BoxList<sl::String> tokenNameList;
[-] 				tokenNameList.insertHead (state->m_token->m_name);
[+] 				tokenNameList.insertHead(state->m_token->m_name);
[-] 			sl::BoxIterator <sl::String> tokenName = tokenNameList.getHead ();
[+] 			sl::BoxIterator<sl::String> tokenName = tokenNameList.getHead();
[-] 				tokenSeqString.append (*tokenName);
[+] 				tokenSeqString.append(*tokenName);
[-] 				tokenSeqString.append (' ');
[+] 				tokenSeqString.append(' ');
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				conflict->m_symbol->m_name.sz (),
[+] 				conflict->m_symbol->m_name.sz(),
[-] 				conflict->m_token->m_name.sz (),
[+] 				conflict->m_token->m_name.sz(),
[-] 				tokenSeqString.sz ()
[+] 				tokenSeqString.sz()
[-] 			lex::pushSrcPosError (conflict->m_symbol->m_srcPos);
[+] 			lex::pushSrcPosError(conflict->m_symbol->m_srcPos);
[-] 	sl::Iterator <LaDfaState> it = m_stateList.getHead ();
[+] 	sl::Iterator<LaDfaState> it = m_stateList.getHead();
[-] 		if (state->m_completeThreadList.getCount () > 1 ||
[+] 		if (state->m_completeThreadList.getCount() > 1 ||
[-] 			state->m_epsilonThreadList.getCount () > 1)
[+] 			state->m_epsilonThreadList.getCount() > 1)
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				conflict->m_symbol->m_name.sz (),
[+] 				conflict->m_symbol->m_name.sz(),
[-] 				conflict->m_token->m_name.sz (),
[+] 				conflict->m_token->m_name.sz(),
[-] 				state->m_token->m_name.sz ()
[+] 				state->m_token->m_name.sz()
[-] 			lex::pushSrcPosError (conflict->m_symbol->m_srcPos);
[+] 			lex::pushSrcPosError(conflict->m_symbol->m_srcPos);
[-] 		if (!state->m_resolverThreadList.isEmpty ()) // chain all resolvers
[+] 		if (!state->m_resolverThreadList.isEmpty()) // chain all resolvers
[-] 			size_t count = state->m_resolverThreadList.getCount ();
[+] 			size_t count = state->m_resolverThreadList.getCount();
[-] 			sl::Array <LaDfaThread*> resolverThreadArray;
[+] 			sl::Array<LaDfaThread*> resolverThreadArray;
[-] 			resolverThreadArray.setCount (count);
[+] 			resolverThreadArray.setCount(count);
[-] 			sl::Iterator <LaDfaThread> resolverThread = state->m_resolverThreadList.getHead ();
[+] 			sl::Iterator<LaDfaThread> resolverThread = state->m_resolverThreadList.getHead();
[-] 				resolverThreadArray [i] = *resolverThread;
[+] 				resolverThreadArray[i] = *resolverThread;
[-] 			qsort (resolverThreadArray, count, sizeof (LaDfaThread*), cmpResolverThreadPriority);
[+] 			qsort(resolverThreadArray, count, sizeof(LaDfaThread*), cmpResolverThreadPriority);
[-] 				LaDfaThread* resolverThread = resolverThreadArray [i];
[+] 				LaDfaThread* resolverThread = resolverThreadArray[i];
[-] 				LaDfaNode* dfaElse = m_nodeMgr->createLaDfaNode ();
[+] 				LaDfaNode* dfaElse = m_nodeMgr->createLaDfaNode();
[-] 				state->m_dfaNode->m_transitionArray.clear ();
[+] 				state->m_dfaNode->m_transitionArray.clear();
[-] 		ASSERT (!state->m_dfaNode->m_resolver);
[+] 		ASSERT(!state->m_dfaNode->m_resolver);
[-] 		if (state->isResolved ())
[+] 		if (state->isResolved())
[-] 			state->m_dfaNode->m_production = state->getResolvedProduction ();
[+] 			state->m_dfaNode->m_production = state->getResolvedProduction();
[-] 					m_nodeMgr->deleteLaDfaNode (state->m_dfaNode);
[+] 					m_nodeMgr->deleteLaDfaNode(state->m_dfaNode);
[-] 			state->m_dfaNode->m_production = state->getDefaultProduction ();
[+] 			state->m_dfaNode->m_production = state->getDefaultProduction();
[-] 		trace ();
[+] 		trace();
[-] 	if (state1->m_resolverThreadList.isEmpty () &&
[+] 	if (state1->m_resolverThreadList.isEmpty() &&
[-] LaDfaBuilder::trace ()
[+] LaDfaBuilder::trace()
[-] 	sl::Iterator <LaDfaState> it = m_stateList.getHead ();
[+] 	sl::Iterator<LaDfaState> it = m_stateList.getHead();
[-] 		printf (
[+] 		printf(
[-] 			state->isResolved () ? "*" : " ",
[+] 			state->isResolved() ? "*" : " ",
[-] 			state->m_activeThreadList.getCount (),
[+] 			state->m_activeThreadList.getCount(),
[-] 			state->m_resolverThreadList.getCount (),
[+] 			state->m_resolverThreadList.getCount(),
[-] 			state->m_completeThreadList.getCount (),
[+] 			state->m_completeThreadList.getCount(),
[-] 			state->m_epsilonThreadList.getCount ()
[+] 			state->m_epsilonThreadList.getCount()
[-] 		sl::Iterator <LaDfaThread> thread;
[+] 		sl::Iterator<LaDfaThread> thread;
[-] 		if (!state->m_activeThreadList.isEmpty ())
[+] 		if (!state->m_activeThreadList.isEmpty())
[-] 			printf ("\tACTIVE:   ");
[+] 			printf("\tACTIVE:   ");
[-] 			thread = state->m_activeThreadList.getHead ();
[+] 			thread = state->m_activeThreadList.getHead();
[-] 				printf ("%s ", thread->m_production->m_name.sz ());
[+] 				printf("%s ", thread->m_production->m_name.sz ());
[-] 			printf ("\n");
[+] 			printf("\n");
[-] 		if (!state->m_resolverThreadList.isEmpty ())
[+] 		if (!state->m_resolverThreadList.isEmpty())
[-] 			printf ("\tRESOLVER: ");
[+] 			printf("\tRESOLVER: ");
[-] 			thread = state->m_resolverThreadList.getHead ();
[+] 			thread = state->m_resolverThreadList.getHead();
[-] 				printf ("%s ", thread->m_production->m_name.sz ());
[+] 				printf("%s ", thread->m_production->m_name.sz ());
[-] 			printf ("\n");
[+] 			printf("\n");
[-] 		if (!state->m_completeThreadList.isEmpty ())
[+] 		if (!state->m_completeThreadList.isEmpty())
[-] 			printf ("\tCOMPLETE: ");
[+] 			printf("\tCOMPLETE: ");
[-] 			thread = state->m_completeThreadList.getHead ();
[+] 			thread = state->m_completeThreadList.getHead();
[-] 				printf ("%s ", thread->m_production->m_name.sz ());
[+] 				printf("%s ", thread->m_production->m_name.sz ());
[-] 			printf ("\n");
[+] 			printf("\n");
[-] 		if (!state->m_epsilonThreadList.isEmpty ())
[+] 		if (!state->m_epsilonThreadList.isEmpty())
[-] 			printf ("\tEPSILON: ");
[+] 			printf("\tEPSILON: ");
[-] 			thread = state->m_epsilonThreadList.getHead ();
[+] 			thread = state->m_epsilonThreadList.getHead();
[-] 				printf ("%s ", thread->m_production->m_name.sz ());
[+] 				printf("%s ", thread->m_production->m_name.sz ());
[-] 			printf ("\n");
[+] 			printf("\n");
[-] 		if (!state->isResolved ())
[+] 		if (!state->isResolved())
[-] 			size_t moveCount = state->m_transitionArray.getCount ();
[+] 			size_t moveCount = state->m_transitionArray.getCount();
[-] 				LaDfaState* moveTo = state->m_transitionArray [i];
[+] 				LaDfaState* moveTo = state->m_transitionArray[i];
[-] 				printf (
[+] 				printf(
[-] 					moveTo->m_token->m_name.sz (),
[+] 					moveTo->m_token->m_name.sz(),
[-] LaDfaBuilder::createState ()
[+] LaDfaBuilder::createState()
[-] 	LaDfaState* state = AXL_MEM_NEW (LaDfaState);
[+] 	LaDfaState* state = AXL_MEM_NEW(LaDfaState);
[-] 	state->m_index = m_stateList.getCount ();
[+] 	state->m_index = m_stateList.getCount();
[-] 	m_stateList.insertTail (state);
[+] 	m_stateList.insertTail(state);
[-] LaDfaBuilder::transition (
[+] LaDfaBuilder::transition(
[-] 	LaDfaState* newState = createState ();
[+] 	LaDfaState* newState = createState();
[-] 	sl::Iterator <LaDfaThread> threadIt = state->m_activeThreadList.getHead ();
[+] 	sl::Iterator<LaDfaThread> threadIt = state->m_activeThreadList.getHead();
[-] 		LaDfaThread* newThread = newState->createThread (*threadIt);
[+] 		LaDfaThread* newThread = newState->createThread(*threadIt);
[-] 		result = processThread (newThread, 0);
[+] 		result = processThread(newThread, 0);
[-] 	threadIt = newState->m_activeThreadList.getHead ();
[+] 	threadIt = newState->m_activeThreadList.getHead();
[-] 		if (thread->m_match == LaDfaThreadMatchKind_AnyToken && newState->isAnyTokenIgnored ())
[+] 		if (thread->m_match == LaDfaThreadMatchKind_AnyToken && newState->isAnyTokenIgnored())
[-] 			newState->m_activeThreadList.erase (thread); // delete anytoken thread in favor of concrete token
[+] 			newState->m_activeThreadList.erase(thread); // delete anytoken thread in favor of concrete token
[-] 		else if (thread->m_stack.isEmpty ())
[+] 		else if (thread->m_stack.isEmpty())
[-] 			newState->m_activeThreadList.remove (thread);
[+] 			newState->m_activeThreadList.remove(thread);
[-] 				newState->m_completeThreadList.insertTail (thread);
[+] 				newState->m_completeThreadList.insertTail(thread);
[-] 				newState->m_epsilonThreadList.insertTail (thread);
[+] 				newState->m_epsilonThreadList.insertTail(thread);
[-] 	if (newState->isEmpty ())
[+] 	if (newState->isEmpty())
[-] 		m_stateList.erase (newState);
[+] 		m_stateList.erase(newState);
[-] 	newState->m_dfaNode = m_nodeMgr->createLaDfaNode ();
[+] 	newState->m_dfaNode = m_nodeMgr->createLaDfaNode();
[-] 	newState->calcResolved ();
[+] 	newState->calcResolved();
[-] 	state->m_dfaNode->m_transitionArray.append (newState->m_dfaNode);
[+] 	state->m_dfaNode->m_transitionArray.append(newState->m_dfaNode);
[-] 	state->m_transitionArray.append (newState);
[+] 	state->m_transitionArray.append(newState);
[-] LaDfaBuilder::processThread (
[+] LaDfaBuilder::processThread(
[-] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount ();
[+] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount();
[-] 		if (thread->m_stack.isEmpty ())
[+] 		if (thread->m_stack.isEmpty())
[-] 		Node* node = thread->m_stack.getBack ();
[+] 		Node* node = thread->m_stack.getBack();
[-] 		switch (node->m_kind)
[+] 		switch(node->m_kind)
[-] 			ASSERT (node->m_masterIndex);
[+] 			ASSERT(node->m_masterIndex);
[-] 				thread->m_stack.pop ();
[+] 				thread->m_stack.pop();
[-] 				thread->m_state->m_activeThreadList.erase (thread);
[+] 				thread->m_state->m_activeThreadList.erase(thread);
[-] 			thread->m_stack.pop ();
[+] 			thread->m_stack.pop();
[-] 				thread->m_state->m_activeThreadList.erase (thread);
[+] 				thread->m_state->m_activeThreadList.erase(thread);
[-] 			symbol = (SymbolNode*) node;
[+] 			symbol = (SymbolNode*)node;
[-] 				thread->m_state->m_activeThreadList.remove (thread);
[+] 				thread->m_state->m_activeThreadList.remove(thread);
[-] 				thread->m_state->m_resolverThreadList.insertTail (thread);
[+] 				thread->m_state->m_resolverThreadList.insertTail(thread);
[-] 			thread->m_stack.pop ();
[+] 			thread->m_stack.pop();
[-] 				thread->m_stack.append (production);
[+] 				thread->m_stack.append(production);
[-] 			thread->m_stack.pop ();
[+] 			thread->m_stack.pop();
[-] 			sequence = (SequenceNode*) node;
[+] 			sequence = (SequenceNode*)node;
[-] 			childrenCount = sequence->m_sequence.getCount ();
[+] 			childrenCount = sequence->m_sequence.getCount();
[-] 				Node* child = sequence->m_sequence [i];
[+] 				Node* child = sequence->m_sequence[i];
[-] 				thread->m_stack.append (child);
[+] 				thread->m_stack.append(child);
[-] 			thread->m_stack.pop ();
[+] 			thread->m_stack.pop();
[-] 			thread->m_stack.append (((BeaconNode*) node)->m_target);
[+] 			thread->m_stack.append(((BeaconNode*)node)->m_target);
[-] 			thread->m_stack.pop ();
[+] 			thread->m_stack.pop();
[-] 			thread->m_stack.pop ();
[+] 			thread->m_stack.pop();
[-] 			conflict = (ConflictNode*) node;
[+] 			conflict = (ConflictNode*)node;
[-] 			childrenCount = conflict->m_productionArray.getCount ();
[+] 			childrenCount = conflict->m_productionArray.getCount();
[-] 				Node* child = conflict->m_productionArray [i];
[+] 				Node* child = conflict->m_productionArray[i];
[-] 				LaDfaThread* newThread = thread->m_state->createThread (thread);
[+] 				LaDfaThread* newThread = thread->m_state->createThread(thread);
[-] 					newThread->m_stack.append (child);
[+] 					newThread->m_stack.append(child);
[-] 				bool result = processThread (newThread, depth);
[+] 				bool result = processThread(newThread, depth);
[-] 			thread->m_state->m_activeThreadList.erase (thread);
[+] 			thread->m_state->m_activeThreadList.erase(thread);
[-] 			ASSERT (false);
[+] 			ASSERT(false);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\main.cpp
----------------------
[-] printVersion ()
[+] printVersion()
[-] 	printf (
[+] 	printf(
[-] printUsage ()
[+] printUsage()
[-] 	printVersion ();
[+] 	printVersion();
[-] 	sl::String helpString = CmdLineSwitchTable::getHelpString ();
[+] 	sl::String helpString = CmdLineSwitchTable::getHelpString();
[-] 	printf ("Usage: graco [<options>...] <source_file>\n%s", helpString.sz ());
[+] 	printf("Usage: graco [<options>...] <source_file>\n%s", helpString.sz ());
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	g::getModule ()->setTag ("graco");
[+] 	g::getModule()->setTag("graco");
[-] 	lex::registerParseErrorProvider ();
[+] 	lex::registerParseErrorProvider();
[-] 	CmdLineParser cmdLineParser (&cmdLine);
[+] 	CmdLineParser cmdLineParser(&cmdLine);
[-] 	result = cmdLineParser.parse (argc, argv);
[+] 	result = cmdLineParser.parse(argc, argv);
[-] 	if (cmdLine.m_inputFileName.isEmpty ())
[+] 	if (cmdLine.m_inputFileName.isEmpty())
[-] 		printUsage ();
[+] 		printUsage();
[-] 	sl::String srcFilePath = io::getFullFilePath (cmdLine.m_inputFileName);
[+] 	sl::String srcFilePath = io::getFullFilePath(cmdLine.m_inputFileName);
[-] 	if (srcFilePath.isEmpty ())
[+] 	if (srcFilePath.isEmpty())
[-] 		printf (
[+] 		printf(
[-] 			cmdLine.m_inputFileName.sz (),
[+] 			cmdLine.m_inputFileName.sz(),
[-] 			err::getLastErrorDescription ().sz ()
[+] 			err::getLastErrorDescription().sz()
[-] 	result = parser.parseFile (&module, &cmdLine, srcFilePath);
[+] 	result = parser.parseFile(&module, &cmdLine, srcFilePath);
[-] 		printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 	if (!module.m_importList.isEmpty ())
[+] 	if (!module.m_importList.isEmpty())
[-] 		sl::StringHashTable <bool> filePathSet;
[+] 		sl::StringHashTable<bool> filePathSet;
[-] 		filePathSet.visit (srcFilePath);
[+] 		filePathSet.visit(srcFilePath);
[-] 		sl::BoxIterator <sl::String> import = module.m_importList.getHead ();
[+] 		sl::BoxIterator<sl::String> import = module.m_importList.getHead();
[-] 			if (filePathSet.find (importFilePath))
[+] 			if (filePathSet.find(importFilePath))
[-] 			result = parser.parseFile (&module, &cmdLine, importFilePath);
[+] 			result = parser.parseFile(&module, &cmdLine, importFilePath);
[-] 				printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 			filePathSet.visit (importFilePath);
[+] 			filePathSet.visit(importFilePath);
[-] 	if (!cmdLine.m_bnfFileName.isEmpty ())
[+] 	if (!cmdLine.m_bnfFileName.isEmpty())
[-] 		result = module.writeBnfFile (cmdLine.m_bnfFileName);
[+] 		result = module.writeBnfFile(cmdLine.m_bnfFileName);
[-] 			printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 	result = module.build (&cmdLine);
[+] 	result = module.build(&cmdLine);
[-] 		printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("%s\n", err::getLastErrorDescription ().sz ());
[-] 		module.trace ();
[+] 		module.trace();
[-] 	generator.prepare (&module);
[+] 	generator.prepare(&module);
[-] 	ASSERT (cmdLine.m_outputFileNameList.getCount () == cmdLine.m_frameFileNameList.getCount ());
[+] 	ASSERT(cmdLine.m_outputFileNameList.getCount() == cmdLine.m_frameFileNameList.getCount());
[-] 	sl::BoxIterator <sl::String> outputFileNameIt = cmdLine.m_outputFileNameList.getHead ();
[+] 	sl::BoxIterator<sl::String> outputFileNameIt = cmdLine.m_outputFileNameList.getHead();
[-] 	sl::BoxIterator <sl::String> frameFileNameIt = cmdLine.m_frameFileNameList.getHead ();
[+] 	sl::BoxIterator<sl::String> frameFileNameIt = cmdLine.m_frameFileNameList.getHead();
[-] 		result = generator.generate (*outputFileNameIt, *frameFileNameIt);
[+] 		result = generator.generate(*outputFileNameIt, *frameFileNameIt);
[-] 			printf ("%s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("%s\n", err::getLastErrorDescription ().sz ());
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\Module.cpp
----------------------
[-] Module::Module ()
[+] Module::Module()
[-] Module::clear ()
[+] Module::clear()
[-] 	m_parseTable.clear ();
[+] 	m_parseTable.clear();
[-] 	m_classMgr.clear ();
[+] 	m_classMgr.clear();
[-] 	m_defineMgr.clear ();
[+] 	m_defineMgr.clear();
[-] 	m_nodeMgr.clear ();
[+] 	m_nodeMgr.clear();
[-] 	m_importList.clear ();
[+] 	m_importList.clear();
[-] Module::build (CmdLine* cmdLine)
[+] Module::build(CmdLine* cmdLine)
[-] 	m_parseTable.clear ();
[+] 	m_parseTable.clear();
[-] 	if (m_nodeMgr.isEmpty ())
[+] 	if (m_nodeMgr.isEmpty())
[-] 		err::setError ("grammar is empty");
[+] 		err::setError("grammar is empty");
[-] 	if (!m_classMgr.verify ())
[+] 	if (!m_classMgr.verify())
[-] 	m_nodeMgr.markReachableNodes ();
[+] 	m_nodeMgr.markReachableNodes();
[-] 	m_nodeMgr.deleteUnreachableNodes ();
[+] 	m_nodeMgr.deleteUnreachableNodes();
[-] 	m_classMgr.deleteUnreachableClasses ();
[+] 	m_classMgr.deleteUnreachableClasses();
[-] 		m_nodeMgr.m_primaryStartSymbol = *m_nodeMgr.m_namedSymbolList.getHead ();
[+] 		m_nodeMgr.m_primaryStartSymbol = *m_nodeMgr.m_namedSymbolList.getHead();
[-] 	m_nodeMgr.indexTokens ();
[+] 	m_nodeMgr.indexTokens();
[-] 	m_nodeMgr.indexSymbols ();
[+] 	m_nodeMgr.indexSymbols();
[-] 	m_nodeMgr.indexSequences ();
[+] 	m_nodeMgr.indexSequences();
[-] 	m_nodeMgr.indexActions ();
[+] 	m_nodeMgr.indexActions();
[-] 	m_nodeMgr.indexArguments ();
[+] 	m_nodeMgr.indexArguments();
[-] 	ProductionBuilder productionBuilder (&m_nodeMgr);
[+] 	ProductionBuilder productionBuilder(&m_nodeMgr);
[-] 	sl::Iterator <SymbolNode> symbolIt = m_nodeMgr.m_namedSymbolList.getHead ();
[+] 	sl::Iterator<SymbolNode> symbolIt = m_nodeMgr.m_namedSymbolList.getHead();
[-] 		size_t count = symbol->m_productionArray.getCount ();
[+] 		size_t count = symbol->m_productionArray.getCount();
[-] 			GrammarNode* production = symbol->m_productionArray [i];
[+] 			GrammarNode* production = symbol->m_productionArray[i];
[-] 			production = productionBuilder.build (symbol, production);
[+] 			production = productionBuilder.build(symbol, production);
[-] 			symbol->m_productionArray [i] = production;
[+] 			symbol->m_productionArray[i] = production;
[-] 	m_nodeMgr.indexBeacons (); // index only after unneeded beacons have been removed
[+] 	m_nodeMgr.indexBeacons(); // index only after unneeded beacons have been removed
[-] 	m_nodeMgr.indexDispatchers ();
[+] 	m_nodeMgr.indexDispatchers();
[-] 	ParseTableBuilder parseTableBuilder (&m_nodeMgr, &m_parseTable);
[+] 	ParseTableBuilder parseTableBuilder(&m_nodeMgr, &m_parseTable);
[-] 	result = parseTableBuilder.build ();
[+] 	result = parseTableBuilder.build();
[-] 	LaDfaBuilder builder (
[+] 	LaDfaBuilder builder(
[-] 	size_t tokenCount = m_nodeMgr.m_tokenArray.getCount ();
[+] 	size_t tokenCount = m_nodeMgr.m_tokenArray.getCount();
[-] 	sl::Iterator <ConflictNode> conflictIt = m_nodeMgr.m_conflictList.getHead ();
[+] 	sl::Iterator<ConflictNode> conflictIt = m_nodeMgr.m_conflictList.getHead();
[-] 		conflict->m_resultNode = builder.build (cmdLine, conflict);
[+] 		conflict->m_resultNode = builder.build(cmdLine, conflict);
[-] 	conflictIt = m_nodeMgr.m_conflictList.getHead ();
[+] 	conflictIt = m_nodeMgr.m_conflictList.getHead();
[-] 		Node** production = &m_parseTable [conflict->m_symbol->m_index * tokenCount + conflict->m_token->m_index];
[+] 		Node** production = &m_parseTable[conflict->m_symbol->m_index * tokenCount + conflict->m_token->m_index];
[-] 		ASSERT (*production == conflict);
[+] 		ASSERT(*production == conflict);
[-] 	m_lookahead = builder.getLookahead ();
[+] 	m_lookahead = builder.getLookahead();
[-] 	m_nodeMgr.indexLaDfaNodes ();
[+] 	m_nodeMgr.indexLaDfaNodes();
[-] Module::trace ()
[+] Module::trace()
[-] 	printf ("lookahead = %d\n", m_lookahead);
[+] 	printf("lookahead = %d\n", m_lookahead);
[-] 	m_nodeMgr.trace ();
[+] 	m_nodeMgr.trace();
[-] Module::writeBnfFile (const sl::StringRef& fileName)
[+] Module::writeBnfFile(const sl::StringRef& fileName)
[-] 		file.open (fileName) &&
[+] 		file.open(fileName) &&
[-] 		file.setSize (0);
[+] 		file.setSize(0);
[-] 	sl::String string = generateBnfString ();
[+] 	sl::String string = generateBnfString();
[-] 	file.write (string, string.getLength ());
[+] 	file.write(string, string.getLength());
[-] Module::generateBnfString ()
[+] Module::generateBnfString()
[-] 	string.format ("lookahead = %d;\n\n", m_lookaheadLimit);
[+] 	string.format("lookahead = %d;\n\n", m_lookaheadLimit);
[-] 	sl::Iterator <SymbolNode> node = m_nodeMgr.m_namedSymbolList.getHead ();
[+] 	sl::Iterator<SymbolNode> node = m_nodeMgr.m_namedSymbolList.getHead();
[-] 		if (symbol->m_productionArray.isEmpty ())
[+] 		if (symbol->m_productionArray.isEmpty())
[-] 			string.append ("start\n");
[+] 			string.append("start\n");
[-] 			string.append ("nullable\n");
[+] 			string.append("nullable\n");
[-] 			string.append ("pragma\n");
[+] 			string.append("pragma\n");
[-] 		string.append (symbol->m_name);
[+] 		string.append(symbol->m_name);
[-] 		string.append ('\n');
[+] 		string.append('\n');
[-] 		size_t productionCount = symbol->m_productionArray.getCount ();
[+] 		size_t productionCount = symbol->m_productionArray.getCount();
[-] 			string.append ("\t:\t");
[+] 			string.append("\t:\t");
[-] 			string.append (symbol->GrammarNode::getBnfString ());
[+] 			string.append(symbol->GrammarNode::getBnfString());
[-] 			string.append ('\n');
[+] 			string.append('\n');
[-] 			string.append (i ? "\t|\t" : "\t:\t");
[+] 			string.append(i ? "\t|\t" : "\t:\t");
[-] 			string.append (symbol->m_productionArray [i]->getBnfString ());
[+] 			string.append(symbol->m_productionArray[i]->getBnfString());
[-] 			string.append ('\n');
[+] 			string.append('\n');
[-] 		string.append ("\t;\n\n");
[+] 		string.append("\t;\n\n");
[-] Module::luaExport (lua::LuaState* luaState)
[+] Module::luaExport(lua::LuaState* luaState)
[-] 	luaExportDefines (luaState);
[+] 	luaExportDefines(luaState);
[-] 	luaExportClassTable (luaState);
[+] 	luaExportClassTable(luaState);
[-] 	luaExportParseTable (luaState);
[+] 	luaExportParseTable(luaState);
[-] 	luaState->setGlobalInteger ("Lookahead", m_lookahead);
[+] 	luaState->setGlobalInteger("Lookahead", m_lookahead);
[-] 	m_nodeMgr.luaExport (luaState);
[+] 	m_nodeMgr.luaExport(luaState);
[-] Module::luaExportDefines (lua::LuaState* luaState)
[+] Module::luaExportDefines(lua::LuaState* luaState)
[-] 	sl::Iterator <Define> defineIt = m_defineMgr.getHead ();
[+] 	sl::Iterator<Define> defineIt = m_defineMgr.getHead();
[-] 		switch (define->m_kind)
[+] 		switch(define->m_kind)
[-] 			luaState->setGlobalString (define->m_name, define->m_stringValue);
[+] 			luaState->setGlobalString(define->m_name, define->m_stringValue);
[-] 			luaState->setGlobalInteger (define->m_name, define->m_integerValue);
[+] 			luaState->setGlobalInteger(define->m_name, define->m_integerValue);
[-] Module::luaExportClassTable (lua::LuaState* luaState)
[+] Module::luaExportClassTable(lua::LuaState* luaState)
[-] 	size_t count = m_classMgr.getCount ();
[+] 	size_t count = m_classMgr.getCount();
[-] 	luaState->createTable (count);
[+] 	luaState->createTable(count);
[-] 	sl::Iterator <Class> it = m_classMgr.getHead ();
[+] 	sl::Iterator<Class> it = m_classMgr.getHead();
[-] 		cls->luaExport (luaState);
[+] 		cls->luaExport(luaState);
[-] 		luaState->setArrayElement (i);
[+] 		luaState->setArrayElement(i);
[-] 	luaState->setGlobal ("ClassTable");
[+] 	luaState->setGlobal("ClassTable");
[-] Module::luaExportParseTable (lua::LuaState* luaState)
[+] Module::luaExportParseTable(lua::LuaState* luaState)
[-] 	size_t symbolCount = m_nodeMgr.m_symbolArray.getCount ();
[+] 	size_t symbolCount = m_nodeMgr.m_symbolArray.getCount();
[-] 	size_t tokenCount = m_nodeMgr.m_tokenArray.getCount ();
[+] 	size_t tokenCount = m_nodeMgr.m_tokenArray.getCount();
[-] 	luaState->createTable (symbolCount);
[+] 	luaState->createTable(symbolCount);
[-] 		luaState->createTable (tokenCount);
[+] 		luaState->createTable(tokenCount);
[-] 			Node* production = m_parseTable [k];
[+] 			Node* production = m_parseTable[k];
[-] 			luaState->setArrayElementInteger (j + 1, production ? production->m_masterIndex : -1);
[+] 			luaState->setArrayElementInteger(j + 1, production ? production->m_masterIndex : -1);
[-] 		luaState->setArrayElement (i + 1);
[+] 		luaState->setArrayElement(i + 1);
[-] 	luaState->setGlobal ("ParseTable");
[+] 	luaState->setGlobal("ParseTable");
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\Node.cpp
----------------------
[-] Node::Node ()
[+] Node::Node()
[-] Node::trace ()
[+] Node::trace()
[-] 	printf ("%s\n", m_name.sz ());
[+] 	printf("%s\n", m_name.sz ());
[-] Node::markReachable ()
[+] Node::markReachable()
[-] GrammarNode::trace ()
[+] GrammarNode::trace()
[-] 	printf (
[+] 	printf(
[-] 		m_name.sz (),
[+] 		m_name.sz(),
[-] 		nodeArrayToString (&m_firstArray).sz (),
[+] 		nodeArrayToString(&m_firstArray).sz(),
[-] 		isNullable () ? " <eps>" : "",
[+] 		isNullable() ? " <eps>" : "",
[-] 		nodeArrayToString (&m_followArray).sz (),
[+] 		nodeArrayToString(&m_followArray).sz(),
[-] 		isFinal () ? " $" : ""
[+] 		isFinal() ? " $" : ""
[-] GrammarNode::markNullable ()
[+] GrammarNode::markNullable()
[-] 	if (isNullable ())
[+] 	if (isNullable())
[-] GrammarNode::markFinal ()
[+] GrammarNode::markFinal()
[-] 	if (isFinal ())
[+] 	if (isFinal())
[-] GrammarNode::luaExportSrcPos (
[+] GrammarNode::luaExportSrcPos(
[-] 	luaState->setMemberString ("FilePath", m_srcPos.m_filePath);
[+] 	luaState->setMemberString("FilePath", m_srcPos.m_filePath);
[-] 	luaState->setMemberInteger ("Line", lineCol.m_line);
[+] 	luaState->setMemberInteger("Line", lineCol.m_line);
[-] 	luaState->setMemberInteger ("Col", lineCol.m_col);
[+] 	luaState->setMemberInteger("Col", lineCol.m_col);
[-] GrammarNode::stripBeacon ()
[+] GrammarNode::stripBeacon()
[-] 	return m_kind == NodeKind_Beacon ? ((BeaconNode*) this)->m_target : this;
[+] 	return m_kind == NodeKind_Beacon ? ((BeaconNode*)this)->m_target : this;
[-] isParenthesNeeded (const sl::StringRef& string)
[+] isParenthesNeeded(const sl::StringRef& string)
[-] 	const char* p = string.cp ();
[+] 	const char* p = string.cp();
[-] 	const char* end = string.getEnd ();
[+] 	const char* end = string.getEnd();
[-] 		switch (*p)
[+] 		switch(*p)
[-] GrammarNode::getBnfString ()
[+] GrammarNode::getBnfString()
[-] 	ASSERT (m_quantifiedNode);
[+] 	ASSERT(m_quantifiedNode);
[-] 	sl::String string = m_quantifiedNode->getBnfString ();
[+] 	sl::String string = m_quantifiedNode->getBnfString();
[-] 	return sl::formatString (
[+] 	return sl::formatString(
[-] 		isParenthesNeeded (string) ? "(%s)%c" : "%s%c",
[+] 		isParenthesNeeded(string) ? "(%s)%c" : "%s%c",
[-] 		string.sz (),
[+] 		string.sz(),
[-] SymbolNode::SymbolNode ()
[+] SymbolNode::SymbolNode()
[-] SymbolNode::getArgName (size_t index)
[+] SymbolNode::getArgName(size_t index)
[-] 	ASSERT (index < m_argNameList.getCount ());
[+] 	ASSERT(index < m_argNameList.getCount());
[-] 	sl::BoxIterator <sl::String> it = m_argNameList.getHead ();
[+] 	sl::BoxIterator<sl::String> it = m_argNameList.getHead();
[-] SymbolNode::addProduction (GrammarNode* node)
[+] SymbolNode::addProduction(GrammarNode* node)
[-] 		!((SymbolNode*) node)->m_resolver)
[+] 		!((SymbolNode*)node)->m_resolver)
[-] 		m_productionArray.append (((SymbolNode*) node)->m_productionArray); // merge temp symbol productions
[+] 		m_productionArray.append(((SymbolNode*)node)->m_productionArray); // merge temp symbol productions
[-] 		m_productionArray.append (node);
[+] 		m_productionArray.append(node);
[-] SymbolNode::markReachable ()
[+] SymbolNode::markReachable()
[-] 	if (!Node::markReachable ())
[+] 	if (!Node::markReachable())
[-] 		m_resolver->markReachable ();
[+] 		m_resolver->markReachable();
[-] 	size_t count = m_productionArray.getCount ();
[+] 	size_t count = m_productionArray.getCount();
[-] 		Node* child = m_productionArray [i];
[+] 		Node* child = m_productionArray[i];
[-] 		child->markReachable ();
[+] 		child->markReachable();
[-] SymbolNode::trace ()
[+] SymbolNode::trace()
[-] 	GrammarNode::trace ();
[+] 	GrammarNode::trace();
[-] 		printf ("\t  RSLVR:  %s\n", m_resolver->m_name.sz ());
[+] 		printf("\t  RSLVR:  %s\n", m_resolver->m_name.sz ());
[-] 		printf ("\t  CLASS:  %s\n", m_class->m_name.sz ());
[+] 		printf("\t  CLASS:  %s\n", m_class->m_name.sz ());
[-] 	size_t childrenCount = m_productionArray.getCount ();
[+] 	size_t childrenCount = m_productionArray.getCount();
[-] 		Node* child = m_productionArray [i];
[+] 		Node* child = m_productionArray[i];
[-] 		printf ("\t  -> %s\n", child->getProductionString ().sz ());
[+] 		printf("\t  -> %s\n", child->getProductionString ().sz ());
[-] SymbolNode::luaExport (lua::LuaState* luaState)
[+] SymbolNode::luaExport(lua::LuaState* luaState)
[-] 		luaState->createTable (1);
[+] 		luaState->createTable(1);
[-] 			luaState->setMemberBoolean ("IsEofToken", true);
[+] 			luaState->setMemberBoolean("IsEofToken", true);
[-] 			luaState->setMemberBoolean ("IsAnyToken", true);
[+] 			luaState->setMemberBoolean("IsAnyToken", true);
[-] 			luaState->setMemberString ("Name", m_name);
[+] 			luaState->setMemberString("Name", m_name);
[-] 			luaState->setMemberInteger ("Token", m_charToken);
[+] 			luaState->setMemberInteger("Token", m_charToken);
[-] 	luaState->createTable (0, 5);
[+] 	luaState->createTable(0, 5);
[-] 	luaState->setMemberString ("Name", m_name);
[+] 	luaState->setMemberString("Name", m_name);
[-] 	luaState->setMemberBoolean ("IsCustom", !m_arg.isEmpty () || !m_local.isEmpty ());
[+] 	luaState->setMemberBoolean("IsCustom", !m_arg.isEmpty () || !m_local.isEmpty ());
[-] 	luaState->createTable (0, 3);
[+] 	luaState->createTable(0, 3);
[-] 	luaExportSrcPos (luaState, m_srcPos);
[+] 	luaExportSrcPos(luaState, m_srcPos);
[-] 	luaState->setMember ("SrcPos");
[+] 	luaState->setMember("SrcPos");
[-] 		luaState->setMemberBoolean ("IsNoAst", true);
[+] 		luaState->setMemberBoolean("IsNoAst", true);
[-] 		luaState->setMemberString ("Class", m_class->m_name);
[+] 		luaState->setMemberString("Class", m_class->m_name);
[-] 	if (!m_arg.isEmpty ())
[+] 	if (!m_arg.isEmpty())
[-] 		luaState->setMemberString ("Arg", m_arg);
[+] 		luaState->setMemberString("Arg", m_arg);
[-] 		luaState->setMemberInteger ("ArgLine", m_argLineCol.m_line);
[+] 		luaState->setMemberInteger("ArgLine", m_argLineCol.m_line);
[-] 	if (!m_local.isEmpty ())
[+] 	if (!m_local.isEmpty())
[-] 		luaState->setMemberString ("Local", m_local);
[+] 		luaState->setMemberString("Local", m_local);
[-] 		luaState->setMemberInteger ("LocalLine", m_localLineCol.m_line);
[+] 		luaState->setMemberInteger("LocalLine", m_localLineCol.m_line);
[-] 	if (!m_enter.isEmpty ())
[+] 	if (!m_enter.isEmpty())
[-] 		luaState->setMemberString ("Enter", m_enter);
[+] 		luaState->setMemberString("Enter", m_enter);
[-] 		luaState->setMemberInteger ("EnterLine", m_enterLineCol.m_line);
[+] 		luaState->setMemberInteger("EnterLine", m_enterLineCol.m_line);
[-] 	if (!m_leave.isEmpty ())
[+] 	if (!m_leave.isEmpty())
[-] 		luaState->setMemberString ("Leave", m_leave);
[+] 		luaState->setMemberString("Leave", m_leave);
[-] 		luaState->setMemberInteger ("LeaveLine", m_leaveLineCol.m_line);
[+] 		luaState->setMemberInteger("LeaveLine", m_leaveLineCol.m_line);
[-] 	luaState->createTable (m_argNameList.getCount ());
[+] 	luaState->createTable(m_argNameList.getCount());
[-] 	sl::BoxIterator <sl::String> it = m_argNameList.getHead ();
[+] 	sl::BoxIterator<sl::String> it = m_argNameList.getHead();
[-] 		luaState->setArrayElementString (i, *it);
[+] 		luaState->setArrayElementString(i, *it);
[-] 	luaState->setMember ("ArgNameTable");
[+] 	luaState->setMember("ArgNameTable");
[-] 	size_t childrenCount = m_productionArray.getCount ();
[+] 	size_t childrenCount = m_productionArray.getCount();
[-] 	luaState->createTable (childrenCount);
[+] 	luaState->createTable(childrenCount);
[-] 		Node* child = m_productionArray [i];
[+] 		Node* child = m_productionArray[i];
[-] 		luaState->setArrayElementInteger (i + 1, child->m_masterIndex);
[+] 		luaState->setArrayElementInteger(i + 1, child->m_masterIndex);
[-] 	luaState->setMember ("ProductionTable");
[+] 	luaState->setMember("ProductionTable");
[-] SymbolNode::getBnfString ()
[+] SymbolNode::getBnfString()
[-] 		return GrammarNode::getBnfString ();
[+] 		return GrammarNode::getBnfString();
[-] 	size_t productionCount = m_productionArray.getCount ();
[+] 	size_t productionCount = m_productionArray.getCount();
[-] 		return m_productionArray [0]->stripBeacon ()->getBnfString ();
[+] 		return m_productionArray[0]->stripBeacon()->getBnfString();
[-] 	string += m_productionArray [0]->stripBeacon ()->getBnfString ();
[+] 	string += m_productionArray[0]->stripBeacon()->getBnfString();
[-] 		string += m_productionArray [i]->stripBeacon ()->getBnfString ();
[+] 		string += m_productionArray[i]->stripBeacon()->getBnfString();
[-] SequenceNode::SequenceNode ()
[+] SequenceNode::SequenceNode()
[-] SequenceNode::append (GrammarNode* node)
[+] SequenceNode::append(GrammarNode* node)
[-] 		m_sequence.append (((SequenceNode*) node)->m_sequence); // merge sequences
[+] 		m_sequence.append(((SequenceNode*)node)->m_sequence); // merge sequences
[-] 		m_sequence.append (node);
[+] 		m_sequence.append(node);
[-] SequenceNode::markReachable ()
[+] SequenceNode::markReachable()
[-] 	if (!Node::markReachable ())
[+] 	if (!Node::markReachable())
[-] 	size_t count = m_sequence.getCount ();
[+] 	size_t count = m_sequence.getCount();
[-] 		Node* child = m_sequence [i];
[+] 		Node* child = m_sequence[i];
[-] 		child->markReachable ();
[+] 		child->markReachable();
[-] SequenceNode::trace ()
[+] SequenceNode::trace()
[-] 	GrammarNode::trace ();
[+] 	GrammarNode::trace();
[-] 	printf ("\t  %s\n", nodeArrayToString (&m_sequence).sz ());
[+] 	printf("\t  %s\n", nodeArrayToString (&m_sequence).sz ());
[-] SequenceNode::luaExport (lua::LuaState* luaState)
[+] SequenceNode::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable (0, 2);
[+] 	luaState->createTable(0, 2);
[-] 	luaState->setMemberString ("Name", m_name);
[+] 	luaState->setMemberString("Name", m_name);
[-] 	size_t count = m_sequence.getCount ();
[+] 	size_t count = m_sequence.getCount();
[-] 	luaState->createTable (count);
[+] 	luaState->createTable(count);
[-] 		Node* child = m_sequence [j];
[+] 		Node* child = m_sequence[j];
[-] 		luaState->setArrayElementInteger (j + 1, child->m_masterIndex);
[+] 		luaState->setArrayElementInteger(j + 1, child->m_masterIndex);
[-] 	luaState->setMember ("Sequence");
[+] 	luaState->setMember("Sequence");
[-] SequenceNode::getProductionString ()
[+] SequenceNode::getProductionString()
[-] 	return sl::formatString (
[+] 	return sl::formatString(
[-] 		m_name.sz (),
[+] 		m_name.sz(),
[-] 		nodeArrayToString (&m_sequence).sz ()
[+] 		nodeArrayToString(&m_sequence).sz()
[-] SequenceNode::getBnfString ()
[+] SequenceNode::getBnfString()
[-] 		return GrammarNode::getBnfString ();
[+] 		return GrammarNode::getBnfString();
[-] 	size_t sequenceLength = m_sequence.getCount ();
[+] 	size_t sequenceLength = m_sequence.getCount();
[-] 	ASSERT (sequenceLength > 1);
[+] 	ASSERT(sequenceLength > 1);
[-] 		GrammarNode* sequenceEntry = m_sequence [i]->stripBeacon ();
[+] 		GrammarNode* sequenceEntry = m_sequence[i]->stripBeacon();
[-] 		sl::String entryString = sequenceEntry->getBnfString ();
[+] 		sl::String entryString = sequenceEntry->getBnfString();
[-] 		if (entryString.isEmpty ())
[+] 		if (entryString.isEmpty())
[-] 		if (!sequenceString.isEmpty ())
[+] 		if (!sequenceString.isEmpty())
[-] 			sequenceString.append (' ');
[+] 			sequenceString.append(' ');
[-] 		sequenceString.append (entryString);
[+] 		sequenceString.append(entryString);
[-] UserNode::UserNode ()
[+] UserNode::UserNode()
[-] ActionNode::ActionNode ()
[+] ActionNode::ActionNode()
[-] ActionNode::trace ()
[+] ActionNode::trace()
[-] 	printf (
[+] 	printf(
[-] 		m_name.sz (),
[+] 		m_name.sz(),
[-] 		m_productionSymbol->m_name.sz (),
[+] 		m_productionSymbol->m_name.sz(),
[-] 		m_dispatcher ? m_dispatcher->m_name.sz () : "NONE",
[+] 		m_dispatcher ? m_dispatcher->m_name.sz() : "NONE",
[-] 		m_userCode.sz ()
[+] 		m_userCode.sz()
[-] ActionNode::luaExport (lua::LuaState* luaState)
[+] ActionNode::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable (0, 2);
[+] 	luaState->createTable(0, 2);
[-] 		luaState->getGlobalArrayElement ("DispatcherTable", m_dispatcher->m_index + 1);
[+] 		luaState->getGlobalArrayElement("DispatcherTable", m_dispatcher->m_index + 1);
[-] 		luaState->setMember ("Dispatcher");
[+] 		luaState->setMember("Dispatcher");
[-] 	luaState->getGlobalArrayElement ("SymbolTable", m_productionSymbol->m_index + 1);
[+] 	luaState->getGlobalArrayElement("SymbolTable", m_productionSymbol->m_index + 1);
[-] 	luaState->setMember ("ProductionSymbol");
[+] 	luaState->setMember("ProductionSymbol");
[-] 	luaState->setMemberString ("UserCode", m_userCode);
[+] 	luaState->setMemberString("UserCode", m_userCode);
[-] 	luaState->createTable (0, 3);
[+] 	luaState->createTable(0, 3);
[-] 	luaExportSrcPos (luaState, m_srcPos);
[+] 	luaExportSrcPos(luaState, m_srcPos);
[-] 	luaState->setMember ("SrcPos");
[+] 	luaState->setMember("SrcPos");
[-] ArgumentNode::ArgumentNode ()
[+] ArgumentNode::ArgumentNode()
[-] ArgumentNode::trace ()
[+] ArgumentNode::trace()
[-] 	printf (
[+] 	printf(
[-] 		m_name.sz (),
[+] 		m_name.sz(),
[-] 		m_productionSymbol->m_name.sz (),
[+] 		m_productionSymbol->m_name.sz(),
[-] 		m_dispatcher ? m_dispatcher->m_name.sz () : "NONE",
[+] 		m_dispatcher ? m_dispatcher->m_name.sz() : "NONE",
[-] 		m_targetSymbol->m_name.sz ()
[+] 		m_targetSymbol->m_name.sz()
[-] 	sl::BoxIterator <sl::String> it = m_argValueList.getHead ();
[+] 	sl::BoxIterator<sl::String> it = m_argValueList.getHead();
[-] 	ASSERT (it); // empty argument should have been eliminated
[+] 	ASSERT(it); // empty argument should have been eliminated
[-] 	printf ("%s", it->sz ());
[+] 	printf("%s", it->sz ());
[-] 		printf (", %s", it->sz ());
[+] 		printf(", %s", it->sz ());
[-] 	printf (">\n");
[+] 	printf(">\n");
[-] ArgumentNode::luaExport (lua::LuaState* luaState)
[+] ArgumentNode::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable (0, 3);
[+] 	luaState->createTable(0, 3);
[-] 		luaState->getGlobalArrayElement ("DispatcherTable", m_dispatcher->m_index + 1);
[+] 		luaState->getGlobalArrayElement("DispatcherTable", m_dispatcher->m_index + 1);
[-] 		luaState->setMember ("Dispatcher");
[+] 		luaState->setMember("Dispatcher");
[-] 	luaState->getGlobalArrayElement ("SymbolTable", m_productionSymbol->m_index + 1);
[+] 	luaState->getGlobalArrayElement("SymbolTable", m_productionSymbol->m_index + 1);
[-] 	luaState->setMember ("ProductionSymbol");
[+] 	luaState->setMember("ProductionSymbol");
[-] 	luaState->getGlobalArrayElement ("SymbolTable", m_targetSymbol->m_index + 1);
[+] 	luaState->getGlobalArrayElement("SymbolTable", m_targetSymbol->m_index + 1);
[-] 	luaState->setMember ("TargetSymbol");
[+] 	luaState->setMember("TargetSymbol");
[-] 	luaState->createTable (m_argValueList.getCount ());
[+] 	luaState->createTable(m_argValueList.getCount());
[-] 	sl::BoxIterator <sl::String> it = m_argValueList.getHead ();
[+] 	sl::BoxIterator<sl::String> it = m_argValueList.getHead();
[-] 	ASSERT (it); // empty argument should have been eliminated
[+] 	ASSERT(it); // empty argument should have been eliminated
[-] 		luaState->setArrayElementString (i, *it);
[+] 		luaState->setArrayElementString(i, *it);
[-] 	luaState->setMember ("ValueTable");
[+] 	luaState->setMember("ValueTable");
[-] 	luaState->createTable (0, 3);
[+] 	luaState->createTable(0, 3);
[-] 	luaExportSrcPos (luaState, m_srcPos);
[+] 	luaExportSrcPos(luaState, m_srcPos);
[-] 	luaState->setMember ("SrcPos");
[+] 	luaState->setMember("SrcPos");
[-] BeaconNode::BeaconNode ()
[+] BeaconNode::BeaconNode()
[-] BeaconNode::markReachable ()
[+] BeaconNode::markReachable()
[-] 	if (!Node::markReachable ())
[+] 	if (!Node::markReachable())
[-] 	m_target->markReachable ();
[+] 	m_target->markReachable();
[-] BeaconNode::trace ()
[+] BeaconNode::trace()
[-] 	ASSERT (m_target);
[+] 	ASSERT(m_target);
[-] 	GrammarNode::trace ();
[+] 	GrammarNode::trace();
[-] 	printf (
[+] 	printf(
[-] 		m_target->m_name.sz ()
[+] 		m_target->m_name.sz()
[-] BeaconNode::luaExport (lua::LuaState* luaState)
[+] BeaconNode::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable (0, 2);
[+] 	luaState->createTable(0, 2);
[-] 	luaState->setMemberInteger ("Slot", m_slotIndex);
[+] 	luaState->setMemberInteger("Slot", m_slotIndex);
[-] 	luaState->setMemberInteger ("Target", m_target->m_masterIndex);
[+] 	luaState->setMemberInteger("Target", m_target->m_masterIndex);
[-] DispatcherNode::trace ()
[+] DispatcherNode::trace()
[-] 	ASSERT (m_symbol);
[+] 	ASSERT(m_symbol);
[-] 	printf (
[+] 	printf(
[-] 		m_name.sz (),
[+] 		m_name.sz(),
[-] 		m_symbol->m_name.sz (),
[+] 		m_symbol->m_name.sz(),
[-] 		nodeArrayToString (&m_beaconArray).sz ()
[+] 		nodeArrayToString(&m_beaconArray).sz()
[-] DispatcherNode::luaExport (lua::LuaState* luaState)
[+] DispatcherNode::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable (0, 3);
[+] 	luaState->createTable(0, 3);
[-] 	luaState->getGlobalArrayElement ("SymbolTable", m_symbol->m_index + 1);
[+] 	luaState->getGlobalArrayElement("SymbolTable", m_symbol->m_index + 1);
[-] 	luaState->setMember ("Symbol");
[+] 	luaState->setMember("Symbol");
[-] 	size_t beaconCount = m_beaconArray.getCount ();
[+] 	size_t beaconCount = m_beaconArray.getCount();
[-] 	luaState->createTable (beaconCount);
[+] 	luaState->createTable(beaconCount);
[-] 		BeaconNode* beacon = m_beaconArray [j];
[+] 		BeaconNode* beacon = m_beaconArray[j];
[-] 		ASSERT (beacon->m_slotIndex == j);
[+] 		ASSERT(beacon->m_slotIndex == j);
[-] 		luaState->createTable (1);
[+] 		luaState->createTable(1);
[-] 			luaState->getGlobalArrayElement ("SymbolTable", beacon->m_target->m_index + 1);
[+] 			luaState->getGlobalArrayElement("SymbolTable", beacon->m_target->m_index + 1);
[-] 			luaState->setMember ("Symbol");
[+] 			luaState->setMember("Symbol");
[-] 		luaState->setArrayElement (j + 1);
[+] 		luaState->setArrayElement(j + 1);
[-] 	luaState->setMember ("BeaconTable");
[+] 	luaState->setMember("BeaconTable");
[-] ConflictNode::ConflictNode ()
[+] ConflictNode::ConflictNode()
[-] ConflictNode::trace ()
[+] ConflictNode::trace()
[-] 	ASSERT (m_symbol);
[+] 	ASSERT(m_symbol);
[-] 	ASSERT (m_token);
[+] 	ASSERT(m_token);
[-] 	printf (
[+] 	printf(
[-] 		m_name.sz (),
[+] 		m_name.sz(),
[-] 		m_token->m_name.sz (),
[+] 		m_token->m_name.sz(),
[-] 		m_symbol->m_name.sz (),
[+] 		m_symbol->m_name.sz(),
[-] 		m_resultNode ? m_resultNode->m_name.sz () : "<none>"
[+] 		m_resultNode ? m_resultNode->m_name.sz() : "<none>"
[-] 	size_t count = m_productionArray.getCount ();
[+] 	size_t count = m_productionArray.getCount();
[-] 		Node* node = m_productionArray [i];
[+] 		Node* node = m_productionArray[i];
[-] 		printf ("\t  \t-> %s\n", node->getProductionString ().sz ());
[+] 		printf("\t  \t-> %s\n", node->getProductionString ().sz ());
[-] LaDfaNode::LaDfaNode ()
[+] LaDfaNode::LaDfaNode()
[-] LaDfaNode::trace ()
[+] LaDfaNode::trace()
[-] 	printf (
[+] 	printf(
[-] 		m_name.sz (),
[+] 		m_name.sz(),
[-] 		printf (
[+] 		printf(
[-] 			m_resolver->m_name.sz (),
[+] 			m_resolver->m_name.sz(),
[-] 			m_production->getProductionString ().sz (),
[+] 			m_production->getProductionString().sz(),
[-] 			m_resolverElse->getProductionString ().sz ()
[+] 			m_resolverElse->getProductionString().sz()
[-] 		size_t count = m_transitionArray.getCount ();
[+] 		size_t count = m_transitionArray.getCount();
[-] 			LaDfaNode* child = m_transitionArray [i];
[+] 			LaDfaNode* child = m_transitionArray[i];
[-] 			printf (
[+] 			printf(
[-] 				child->m_token->m_name.sz (),
[+] 				child->m_token->m_name.sz(),
[-] 				child->getProductionString ().sz ()
[+] 				child->getProductionString().sz()
[-] 			printf (
[+] 			printf(
[-] 				m_production->getProductionString ().sz ()
[+] 				m_production->getProductionString().sz()
[-] 	printf ("\n");
[+] 	printf("\n");
[-] getTransitionIndex (Node* node)
[+] getTransitionIndex(Node* node)
[-] 	LaDfaNode* laDfaNode = (LaDfaNode*) node;
[+] 	LaDfaNode* laDfaNode = (LaDfaNode*)node;
[-] 	ASSERT (laDfaNode->m_production && laDfaNode->m_production->m_kind != NodeKind_LaDfa);
[+] 	ASSERT(laDfaNode->m_production && laDfaNode->m_production->m_kind != NodeKind_LaDfa);
[-] LaDfaNode::luaExportResolverMembers (lua::LuaState* luaState)
[+] LaDfaNode::luaExportResolverMembers(lua::LuaState* luaState)
[-] 	luaState->setMemberString ("Name", m_name);
[+] 	luaState->setMemberString("Name", m_name);
[-] 	luaState->setMemberInteger ("Resolver", m_resolver->m_masterIndex);
[+] 	luaState->setMemberInteger("Resolver", m_resolver->m_masterIndex);
[-] 	luaState->setMemberInteger ("Production", m_production->m_masterIndex);
[+] 	luaState->setMemberInteger("Production", m_production->m_masterIndex);
[-] 	luaState->setMemberInteger ("ResolverElse", getTransitionIndex (m_resolverElse));
[+] 	luaState->setMemberInteger("ResolverElse", getTransitionIndex (m_resolverElse));
[-] 	luaState->setMemberBoolean ("HasChainedResolver", ((LaDfaNode*) m_resolverElse)->m_resolver != NULL);
[+] 	luaState->setMemberBoolean("HasChainedResolver", ((LaDfaNode*) m_resolverElse)->m_resolver != NULL);
[-] LaDfaNode::luaExport (lua::LuaState* luaState)
[+] LaDfaNode::luaExport(lua::LuaState* luaState)
[-] 	ASSERT (!(m_flags & LaDfaNodeFlag_Leaf));
[+] 	ASSERT(!(m_flags & LaDfaNodeFlag_Leaf));
[-] 		luaState->createTable (0, 3);
[+] 		luaState->createTable(0, 3);
[-] 		luaExportResolverMembers (luaState);
[+] 		luaExportResolverMembers(luaState);
[-] 	size_t childrenCount = m_transitionArray.getCount ();
[+] 	size_t childrenCount = m_transitionArray.getCount();
[-] 	ASSERT (childrenCount);
[+] 	ASSERT(childrenCount);
[-] 	luaState->createTable (0, 2);
[+] 	luaState->createTable(0, 2);
[-] 	luaState->createTable (childrenCount);
[+] 	luaState->createTable(childrenCount);
[-] 		LaDfaNode* child = m_transitionArray [i];
[+] 		LaDfaNode* child = m_transitionArray[i];
[-] 		luaState->createTable (0, 4);
[+] 		luaState->createTable(0, 4);
[-] 		luaState->getGlobalArrayElement ("TokenTable", child->m_token->m_index + 1);
[+] 		luaState->getGlobalArrayElement("TokenTable", child->m_token->m_index + 1);
[-] 		luaState->setMember ("Token");
[+] 		luaState->setMember("Token");
[-] 			child->luaExportResolverMembers (luaState);
[+] 			child->luaExportResolverMembers(luaState);
[-] 			luaState->setMemberInteger ("Production", getTransitionIndex (child));
[+] 			luaState->setMemberInteger("Production", getTransitionIndex (child));
[-] 		luaState->setArrayElement (i + 1);
[+] 		luaState->setArrayElement(i + 1);
[-] 	luaState->setMember ("TransitionTable");
[+] 	luaState->setMember("TransitionTable");
[-] 		luaState->setMemberInteger ("DefaultProduction", getTransitionIndex (m_production));
[+] 		luaState->setMemberInteger("DefaultProduction", getTransitionIndex (m_production));
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\NodeMgr.cpp
----------------------
[-] NodeMgr::NodeMgr ()
[+] NodeMgr::NodeMgr()
[-] NodeMgr::clear ()
[+] NodeMgr::clear()
[-] 	m_charTokenList.clear ();
[+] 	m_charTokenList.clear();
[-] 	m_namedTokenList.clear ();
[+] 	m_namedTokenList.clear();
[-] 	m_namedSymbolList.clear ();
[+] 	m_namedSymbolList.clear();
[-] 	m_tempSymbolList.clear ();
[+] 	m_tempSymbolList.clear();
[-] 	m_sequenceList.clear ();
[+] 	m_sequenceList.clear();
[-] 	m_beaconList.clear ();
[+] 	m_beaconList.clear();
[-] 	m_dispatcherList.clear ();
[+] 	m_dispatcherList.clear();
[-] 	m_actionList.clear ();
[+] 	m_actionList.clear();
[-] 	m_argumentList.clear ();
[+] 	m_argumentList.clear();
[-] 	m_conflictList.clear ();
[+] 	m_conflictList.clear();
[-] 	m_laDfaList.clear ();
[+] 	m_laDfaList.clear();
[-] 	m_tokenMap.clear ();
[+] 	m_tokenMap.clear();
[-] 	m_symbolMap.clear ();
[+] 	m_symbolMap.clear();
[-] 	m_anyTokenNode.m_firstArray.clear ();
[+] 	m_anyTokenNode.m_firstArray.clear();
[-] 	m_anyTokenNode.m_firstSet.clear ();
[+] 	m_anyTokenNode.m_firstSet.clear();
[-] 	m_startPragmaSymbol.m_productionArray.clear ();
[+] 	m_startPragmaSymbol.m_productionArray.clear();
[-] NodeMgr::trace ()
[+] NodeMgr::trace()
[-] 	traceNodeArray ("TOKENS", &m_tokenArray);
[+] 	traceNodeArray("TOKENS", &m_tokenArray);
[-] 	traceNodeArray ("SYMBOLS", &m_symbolArray);
[+] 	traceNodeArray("SYMBOLS", &m_symbolArray);
[-] 	traceNodeList ("SEQUENCES", m_sequenceList.getHead ());
[+] 	traceNodeList("SEQUENCES", m_sequenceList.getHead ());
[-] 	traceNodeList ("BEACONS", m_beaconList.getHead ());
[+] 	traceNodeList("BEACONS", m_beaconList.getHead ());
[-] 	traceNodeList ("DISPATCHERS", m_dispatcherList.getHead ());
[+] 	traceNodeList("DISPATCHERS", m_dispatcherList.getHead ());
[-] 	traceNodeList ("ACTIONS", m_actionList.getHead ());
[+] 	traceNodeList("ACTIONS", m_actionList.getHead ());
[-] 	traceNodeList ("ARGUMENTS", m_argumentList.getHead ());
[+] 	traceNodeList("ARGUMENTS", m_argumentList.getHead ());
[-] 	traceNodeList ("CONFLICTS", m_conflictList.getHead ());
[+] 	traceNodeList("CONFLICTS", m_conflictList.getHead ());
[-] 	traceNodeList ("LOOKAHEAD DFA", m_laDfaList.getHead ());
[+] 	traceNodeList("LOOKAHEAD DFA", m_laDfaList.getHead ());
[-] NodeMgr::getTokenNode (int token)
[+] NodeMgr::getTokenNode(int token)
[-] 	sl::HashTableIterator <int, SymbolNode*> mapIt = m_tokenMap.visit (token);
[+] 	sl::HashTableIterator<int, SymbolNode*> mapIt = m_tokenMap.visit(token);
[-] 	SymbolNode* node = AXL_MEM_NEW (SymbolNode);
[+] 	SymbolNode* node = AXL_MEM_NEW(SymbolNode);
[-] 	if (isprint (token))
[+] 	if (isprint(token))
[-] 		node->m_name.format ("\'%c\'", (char) token);
[+] 		node->m_name.format("\'%c\'", (char) token);
[-] 		node->m_name.format ("\\0%d", token);
[+] 		node->m_name.format("\\0%d", token);
[-] 	m_charTokenList.insertTail (node);
[+] 	m_charTokenList.insertTail(node);
[-] NodeMgr::getSymbolNode (const sl::StringRef& name)
[+] NodeMgr::getSymbolNode(const sl::StringRef& name)
[-] 	sl::StringHashTableIterator <SymbolNode*> mapIt = m_symbolMap.visit (name);
[+] 	sl::StringHashTableIterator<SymbolNode*> mapIt = m_symbolMap.visit(name);
[-] 	SymbolNode* node = AXL_MEM_NEW (SymbolNode);
[+] 	SymbolNode* node = AXL_MEM_NEW(SymbolNode);
[-] 	m_namedSymbolList.insertTail (node);
[+] 	m_namedSymbolList.insertTail(node);
[-] NodeMgr::createTempSymbolNode ()
[+] NodeMgr::createTempSymbolNode()
[-] 	SymbolNode* node = AXL_MEM_NEW (SymbolNode);
[+] 	SymbolNode* node = AXL_MEM_NEW(SymbolNode);
[-] 	node->m_name.format ("_tmp%d", m_tempSymbolList.getCount () + 1);
[+] 	node->m_name.format("_tmp%d", m_tempSymbolList.getCount () + 1);
[-] 	m_tempSymbolList.insertTail (node);
[+] 	m_tempSymbolList.insertTail(node);
[-] NodeMgr::createSequenceNode ()
[+] NodeMgr::createSequenceNode()
[-] 	SequenceNode* node = AXL_MEM_NEW (SequenceNode);
[+] 	SequenceNode* node = AXL_MEM_NEW(SequenceNode);
[-] 	node->m_name.format ("_seq%d", m_sequenceList.getCount () + 1);
[+] 	node->m_name.format("_seq%d", m_sequenceList.getCount () + 1);
[-] 	m_sequenceList.insertTail (node);
[+] 	m_sequenceList.insertTail(node);
[-] NodeMgr::createSequenceNode (GrammarNode* node)
[+] NodeMgr::createSequenceNode(GrammarNode* node)
[-] 	SequenceNode* sequenceNode = createSequenceNode ();
[+] 	SequenceNode* sequenceNode = createSequenceNode();
[-] 	sequenceNode->append (node);
[+] 	sequenceNode->append(node);
[-] NodeMgr::createBeaconNode (SymbolNode* target)
[+] NodeMgr::createBeaconNode(SymbolNode* target)
[-] 	BeaconNode* beaconNode = AXL_MEM_NEW (BeaconNode);
[+] 	BeaconNode* beaconNode = AXL_MEM_NEW(BeaconNode);
[-] 	beaconNode->m_name.format (
[+] 	beaconNode->m_name.format(
[-] 		m_beaconList.getCount () + 1,
[+] 		m_beaconList.getCount() + 1,
[-] 		target->m_name.sz ()
[+] 		target->m_name.sz()
[-] 	m_beaconList.insertTail (beaconNode);
[+] 	m_beaconList.insertTail(beaconNode);
[-] NodeMgr::createDispatcherNode (SymbolNode* symbol)
[+] NodeMgr::createDispatcherNode(SymbolNode* symbol)
[-] 	DispatcherNode* dispatcherNode = AXL_MEM_NEW (DispatcherNode);
[+] 	DispatcherNode* dispatcherNode = AXL_MEM_NEW(DispatcherNode);
[-] 	dispatcherNode->m_name.format ("_dsp%d", m_dispatcherList.getCount () + 1);
[+] 	dispatcherNode->m_name.format("_dsp%d", m_dispatcherList.getCount () + 1);
[-] 	m_dispatcherList.insertTail (dispatcherNode);
[+] 	m_dispatcherList.insertTail(dispatcherNode);
[-] NodeMgr::createActionNode ()
[+] NodeMgr::createActionNode()
[-] 	ActionNode* node = AXL_MEM_NEW (ActionNode);
[+] 	ActionNode* node = AXL_MEM_NEW(ActionNode);
[-] 	node->m_name.format ("_act%d", m_actionList.getCount () + 1);
[+] 	node->m_name.format("_act%d", m_actionList.getCount () + 1);
[-] 	m_actionList.insertTail (node);
[+] 	m_actionList.insertTail(node);
[-] NodeMgr::createArgumentNode ()
[+] NodeMgr::createArgumentNode()
[-] 	ArgumentNode* node = AXL_MEM_NEW (ArgumentNode);
[+] 	ArgumentNode* node = AXL_MEM_NEW(ArgumentNode);
[-] 	node->m_name.format ("_arg%d", m_argumentList.getCount () + 1);
[+] 	node->m_name.format("_arg%d", m_argumentList.getCount () + 1);
[-] 	m_argumentList.insertTail (node);
[+] 	m_argumentList.insertTail(node);
[-] NodeMgr::createConflictNode ()
[+] NodeMgr::createConflictNode()
[-] 	ConflictNode* node = AXL_MEM_NEW (ConflictNode);
[+] 	ConflictNode* node = AXL_MEM_NEW(ConflictNode);
[-] 	node->m_name.format ("_cnf%d", m_conflictList.getCount () + 1);
[+] 	node->m_name.format("_cnf%d", m_conflictList.getCount () + 1);
[-] 	m_conflictList.insertTail (node);
[+] 	m_conflictList.insertTail(node);
[-] NodeMgr::createLaDfaNode ()
[+] NodeMgr::createLaDfaNode()
[-] 	LaDfaNode* node = AXL_MEM_NEW (LaDfaNode);
[+] 	LaDfaNode* node = AXL_MEM_NEW(LaDfaNode);
[-] 	node->m_name.format ("_dfa%d", m_laDfaList.getCount () + 1);
[+] 	node->m_name.format("_dfa%d", m_laDfaList.getCount () + 1);
[-] 	m_laDfaList.insertTail (node);
[+] 	m_laDfaList.insertTail(node);
[-] NodeMgr::createQuantifierNode (
[+] NodeMgr::createQuantifierNode(
[-] 		err::setFormatStringError ("can't apply quantifier to action or epsilon nodes");
[+] 		err::setFormatStringError("can't apply quantifier to action or epsilon nodes");
[-] 	switch (kind)
[+] 	switch(kind)
[-] 		tempAlt = createTempSymbolNode ();
[+] 		tempAlt = createTempSymbolNode();
[-] 		tempAlt->addProduction (node);
[+] 		tempAlt->addProduction(node);
[-] 		tempAlt->addProduction (&m_epsilonNode);
[+] 		tempAlt->addProduction(&m_epsilonNode);
[-] 		tempAlt = createTempSymbolNode ();
[+] 		tempAlt = createTempSymbolNode();
[-] 		tempSeq = createSequenceNode ();
[+] 		tempSeq = createSequenceNode();
[-] 		tempSeq->append (node);
[+] 		tempSeq->append(node);
[-] 		tempSeq->append (tempAlt);
[+] 		tempSeq->append(tempAlt);
[-] 		tempAlt->addProduction (tempSeq);
[+] 		tempAlt->addProduction(tempSeq);
[-] 		tempAlt->addProduction (&m_epsilonNode);
[+] 		tempAlt->addProduction(&m_epsilonNode);
[-] 		tempSeq = createSequenceNode ();
[+] 		tempSeq = createSequenceNode();
[-] 		tempSeq->append (node);
[+] 		tempSeq->append(node);
[-] 		tempSeq->append (createQuantifierNode (node, '*'));
[+] 		tempSeq->append(createQuantifierNode(node, '*'));
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] NodeMgr::markReachableNodes ()
[+] NodeMgr::markReachableNodes()
[-] 	sl::Iterator <SymbolNode> nodeIt = m_namedSymbolList.getHead ();
[+] 	sl::Iterator<SymbolNode> nodeIt = m_namedSymbolList.getHead();
[-] 				node->markReachable ();
[+] 				node->markReachable();
[-] 			node->markReachable ();
[+] 			node->markReachable();
[-] 	m_startPragmaSymbol.markReachable ();
[+] 	m_startPragmaSymbol.markReachable();
[-] deleteUnreachableNodesFromList (sl::List <T>* list)
[+] deleteUnreachableNodesFromList(sl::List<T>* list)
[-] 	sl::Iterator <T> nodeIt = list->getHead ();
[+] 	sl::Iterator<T> nodeIt = list->getHead();
[-] 		if (!node->isReachable ())
[+] 		if (!node->isReachable())
[-] 			list->erase (node);
[+] 			list->erase(node);
[-] NodeMgr::deleteUnreachableNodes ()
[+] NodeMgr::deleteUnreachableNodes()
[-] 	deleteUnreachableNodesFromList (&m_charTokenList);
[+] 	deleteUnreachableNodesFromList(&m_charTokenList);
[-] 	deleteUnreachableNodesFromList (&m_namedSymbolList);
[+] 	deleteUnreachableNodesFromList(&m_namedSymbolList);
[-] 	deleteUnreachableNodesFromList (&m_tempSymbolList);
[+] 	deleteUnreachableNodesFromList(&m_tempSymbolList);
[-] 	deleteUnreachableNodesFromList (&m_sequenceList);
[+] 	deleteUnreachableNodesFromList(&m_sequenceList);
[-] 	deleteUnreachableNodesFromList (&m_beaconList);
[+] 	deleteUnreachableNodesFromList(&m_beaconList);
[-] 	deleteUnreachableNodesFromList (&m_actionList);
[+] 	deleteUnreachableNodesFromList(&m_actionList);
[-] 	deleteUnreachableNodesFromList (&m_argumentList);
[+] 	deleteUnreachableNodesFromList(&m_argumentList);
[-] NodeMgr::indexTokens ()
[+] NodeMgr::indexTokens()
[-] 	size_t count = m_charTokenList.getCount () + 2;
[+] 	size_t count = m_charTokenList.getCount() + 2;
[-] 	m_tokenArray.setCount (count);
[+] 	m_tokenArray.setCount(count);
[-] 	m_tokenArray [i++] = &m_eofTokenNode;
[+] 	m_tokenArray[i++] = &m_eofTokenNode;
[-] 	m_tokenArray [i++] = &m_anyTokenNode;
[+] 	m_tokenArray[i++] = &m_anyTokenNode;
[-] 	sl::Iterator <SymbolNode> nodeIt = m_charTokenList.getHead ();
[+] 	sl::Iterator<SymbolNode> nodeIt = m_charTokenList.getHead();
[-] 		m_tokenArray [i] = node;
[+] 		m_tokenArray[i] = node;
[-] NodeMgr::indexSymbols ()
[+] NodeMgr::indexSymbols()
[-] 	sl::Iterator <SymbolNode> nodeIt = m_namedSymbolList.getHead ();
[+] 	sl::Iterator<SymbolNode> nodeIt = m_namedSymbolList.getHead();
[-] 		if (!node->m_productionArray.isEmpty ())
[+] 		if (!node->m_productionArray.isEmpty())
[-] 		m_namedSymbolList.remove (node);
[+] 		m_namedSymbolList.remove(node);
[-] 		m_namedTokenList.insertTail (node);
[+] 		m_namedTokenList.insertTail(node);
[-] 		m_tokenArray.append (node);
[+] 		m_tokenArray.append(node);
[-] 	size_t count = m_namedSymbolList.getCount () + m_tempSymbolList.getCount ();
[+] 	size_t count = m_namedSymbolList.getCount() + m_tempSymbolList.getCount();
[-] 	m_symbolArray.setCount (count);
[+] 	m_symbolArray.setCount(count);
[-] 	nodeIt = m_namedSymbolList.getHead ();
[+] 	nodeIt = m_namedSymbolList.getHead();
[-] 		m_symbolArray [i] = node;
[+] 		m_symbolArray[i] = node;
[-] 	nodeIt = m_tempSymbolList.getHead ();
[+] 	nodeIt = m_tempSymbolList.getHead();
[-] 		m_symbolArray [i] = node;
[+] 		m_symbolArray[i] = node;
[-] 	if (!m_startPragmaSymbol.m_productionArray.isEmpty ())
[+] 	if (!m_startPragmaSymbol.m_productionArray.isEmpty())
[-] 		m_symbolArray.append (&m_startPragmaSymbol);
[+] 		m_symbolArray.append(&m_startPragmaSymbol);
[-] NodeMgr::indexSequences ()
[+] NodeMgr::indexSequences()
[-] 	size_t count = m_sequenceList.getCount ();
[+] 	size_t count = m_sequenceList.getCount();
[-] 	sl::Iterator <SequenceNode> nodeIt = m_sequenceList.getHead ();
[+] 	sl::Iterator<SequenceNode> nodeIt = m_sequenceList.getHead();
[-] NodeMgr::indexBeacons ()
[+] NodeMgr::indexBeacons()
[-] 	sl::Iterator <BeaconNode> nodeIt = m_beaconList.getHead ();
[+] 	sl::Iterator<BeaconNode> nodeIt = m_beaconList.getHead();
[-] NodeMgr::indexDispatchers ()
[+] NodeMgr::indexDispatchers()
[-] 	sl::Iterator <DispatcherNode> nodeIt = m_dispatcherList.getHead ();
[+] 	sl::Iterator<DispatcherNode> nodeIt = m_dispatcherList.getHead();
[-] NodeMgr::indexActions ()
[+] NodeMgr::indexActions()
[-] 	sl::Iterator <ActionNode> nodeIt = m_actionList.getHead ();
[+] 	sl::Iterator<ActionNode> nodeIt = m_actionList.getHead();
[-] NodeMgr::indexArguments ()
[+] NodeMgr::indexArguments()
[-] 	sl::Iterator <ArgumentNode> nodeIt = m_argumentList.getHead ();
[+] 	sl::Iterator<ArgumentNode> nodeIt = m_argumentList.getHead();
[-] NodeMgr::indexLaDfaNodes ()
[+] NodeMgr::indexLaDfaNodes()
[-] 	sl::Iterator <LaDfaNode> nodeIt = m_laDfaList.getHead ();
[+] 	sl::Iterator<LaDfaNode> nodeIt = m_laDfaList.getHead();
[-] NodeMgr::luaExport (lua::LuaState* luaState)
[+] NodeMgr::luaExport(lua::LuaState* luaState)
[-] 	luaState->setGlobalInteger ("StartSymbol", m_primaryStartSymbol ? m_primaryStartSymbol->m_index : -1);
[+] 	luaState->setGlobalInteger("StartSymbol", m_primaryStartSymbol ? m_primaryStartSymbol->m_index : -1);
[-] 	luaState->setGlobalInteger ("StartPragmaSymbol", m_startPragmaSymbol.m_index);
[+] 	luaState->setGlobalInteger("StartPragmaSymbol", m_startPragmaSymbol.m_index);
[-] 	luaState->setGlobalInteger ("NamedTokenCount", m_namedTokenList.getCount ());
[+] 	luaState->setGlobalInteger("NamedTokenCount", m_namedTokenList.getCount ());
[-] 	luaState->setGlobalInteger ("NamedSymbolCount", m_namedSymbolList.getCount ());
[+] 	luaState->setGlobalInteger("NamedSymbolCount", m_namedSymbolList.getCount ());
[-] 	luaExportNodeArray (luaState, "TokenTable", (Node**) (SymbolNode**) m_tokenArray, m_tokenArray.getCount ());
[+] 	luaExportNodeArray(luaState, "TokenTable", (Node**) (SymbolNode**) m_tokenArray, m_tokenArray.getCount ());
[-] 	luaExportNodeArray (luaState, "SymbolTable", (Node**) (SymbolNode**) m_symbolArray, m_symbolArray.getCount ());
[+] 	luaExportNodeArray(luaState, "SymbolTable", (Node**) (SymbolNode**) m_symbolArray, m_symbolArray.getCount ());
[-] 	luaExportNodeList (luaState, "SequenceTable", m_sequenceList.getHead (), m_sequenceList.getCount ());
[+] 	luaExportNodeList(luaState, "SequenceTable", m_sequenceList.getHead (), m_sequenceList.getCount ());
[-] 	luaExportNodeList (luaState, "BeaconTable", m_beaconList.getHead (), m_beaconList.getCount ());
[+] 	luaExportNodeList(luaState, "BeaconTable", m_beaconList.getHead (), m_beaconList.getCount ());
[-] 	luaExportNodeList (luaState, "DispatcherTable", m_dispatcherList.getHead (), m_dispatcherList.getCount ());
[+] 	luaExportNodeList(luaState, "DispatcherTable", m_dispatcherList.getHead (), m_dispatcherList.getCount ());
[-] 	luaExportNodeList (luaState, "ActionTable", m_actionList.getHead (), m_actionList.getCount ());
[+] 	luaExportNodeList(luaState, "ActionTable", m_actionList.getHead (), m_actionList.getCount ());
[-] 	luaExportNodeList (luaState, "ArgumentTable", m_argumentList.getHead (), m_argumentList.getCount ());
[+] 	luaExportNodeList(luaState, "ArgumentTable", m_argumentList.getHead (), m_argumentList.getCount ());
[-] 	luaExportLaDfaTable (luaState);
[+] 	luaExportLaDfaTable(luaState);
[-] NodeMgr::luaExportNodeArray (
[+] NodeMgr::luaExportNodeArray(
[-] 	luaState->createTable (count);
[+] 	luaState->createTable(count);
[-] 		Node* node = nodeArray [i];
[+] 		Node* node = nodeArray[i];
[-] 		node->luaExport (luaState);
[+] 		node->luaExport(luaState);
[-] 		luaState->setArrayElement (i + 1);
[+] 		luaState->setArrayElement(i + 1);
[-] 	luaState->setGlobal (name);
[+] 	luaState->setGlobal(name);
[-] NodeMgr::luaExportNodeList (
[+] NodeMgr::luaExportNodeList(
[-] 	sl::Iterator <Node> nodeIt,
[+] 	sl::Iterator<Node> nodeIt,
[-] 	luaState->createTable (countEstimate);
[+] 	luaState->createTable(countEstimate);
[-] 		nodeIt->luaExport (luaState);
[+] 		nodeIt->luaExport(luaState);
[-] 		luaState->setArrayElement (i);
[+] 		luaState->setArrayElement(i);
[-] 	luaState->setGlobal (name);
[+] 	luaState->setGlobal(name);
[-] NodeMgr::luaExportLaDfaTable (lua::LuaState* luaState)
[+] NodeMgr::luaExportLaDfaTable(lua::LuaState* luaState)
[-] 	luaState->createTable (m_laDfaList.getCount ());
[+] 	luaState->createTable(m_laDfaList.getCount());
[-] 	sl::Iterator <LaDfaNode> nodeIt = m_laDfaList.getHead ();
[+] 	sl::Iterator<LaDfaNode> nodeIt = m_laDfaList.getHead();
[-] 			node->luaExport (luaState);
[+] 			node->luaExport(luaState);
[-] 			luaState->setArrayElement (i++);
[+] 			luaState->setArrayElement(i++);
[-] 	luaState->setGlobal ("LaDfaTable");
[+] 	luaState->setGlobal("LaDfaTable");
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\Parser.cpp
----------------------
[-] Parser::parseFile (
[+] Parser::parseFile(
[-] 	result = srcFile.open (filePath, io::FileFlag_ReadOnly);
[+] 	result = srcFile.open(filePath, io::FileFlag_ReadOnly);
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			filePath.sz (),
[+] 			filePath.sz(),
[-] 			err::getLastErrorDescription ().sz ()
[+] 			err::getLastErrorDescription().sz()
[-] 	size_t size = (size_t) srcFile.getSize ();
[+] 	size_t size = (size_t)srcFile.getSize();
[-] 	char* p = (char*) srcFile.view (0, size);
[+] 	char* p = (char*)srcFile.view(0, size);
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			filePath.sz (),
[+] 			filePath.sz(),
[-] 			err::getLastErrorDescription ().sz ()
[+] 			err::getLastErrorDescription().sz()
[-] 	return parse (module, cmdLine, filePath, sl::StringRef (p, size));
[+] 	return parse(module, cmdLine, filePath, sl::StringRef(p, size));
[-] Parser::parse (
[+] Parser::parse(
[-] 	m_dir = io::getDir (filePath);
[+] 	m_dir = io::getDir(filePath);
[-] 	m_defaultProductionSpecifiers.reset ();
[+] 	m_defaultProductionSpecifiers.reset();
[-] 	Lexer::create (filePath, source);
[+] 	Lexer::create(filePath, source);
[-] 	result = program ();
[+] 	result = program();
[-] 		ensureSrcPosError ();
[+] 		ensureSrcPosError();
[-] Parser::program ()
[+] Parser::program()
[-] 		const Token* token = getToken ();
[+] 		const Token* token = getToken();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 			result = lookaheadStatement ();
[+] 			result = lookaheadStatement();
[-] 			result = importStatement ();
[+] 			result = importStatement();
[-] 			result = usingStatement ();
[+] 			result = usingStatement();
[-] 			nextToken ();
[+] 			nextToken();
[-] 			laToken = getToken (1);
[+] 			laToken = getToken(1);
[-] 				result = defineStatement ();
[+] 				result = defineStatement();
[-] 			result = declarationStatement ();
[+] 			result = declarationStatement();
[-] Parser::lookaheadStatement ()
[+] Parser::lookaheadStatement()
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	ASSERT (token->m_token == TokenKind_Lookahead);
[+] 	ASSERT(token->m_token == TokenKind_Lookahead);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = expectToken ('=');
[+] 	token = expectToken('=');
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = expectToken (TokenKind_Integer);
[+] 	token = expectToken(TokenKind_Integer);
[-] 		err::setFormatStringError ("redefinition of lookahead limit (previously seen as %d)", m_module->m_lookaheadLimit);
[+] 		err::setFormatStringError("redefinition of lookahead limit (previously seen as %d)", m_module->m_lookaheadLimit);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = expectToken (';');
[+] 	token = expectToken(';');
[-] 	nextToken ();
[+] 	nextToken();
[-] Parser::importStatement ()
[+] Parser::importStatement()
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	ASSERT (token->m_token == TokenKind_Import);
[+] 	ASSERT(token->m_token == TokenKind_Import);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = expectToken (TokenKind_Literal);
[+] 	token = expectToken(TokenKind_Literal);
[-] 	sl::String filePath = io::findFilePath (
[+] 	sl::String filePath = io::findFilePath(
[-] 	if (filePath.isEmpty ())
[+] 	if (filePath.isEmpty())
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			token->m_data.m_string.sz ()
[+] 			token->m_data.m_string.sz()
[-] 	m_module->m_importList.insertTail (filePath);
[+] 	m_module->m_importList.insertTail(filePath);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = expectToken (';');
[+] 	token = expectToken(';');
[-] 	nextToken ();
[+] 	nextToken();
[-] Parser::declarationStatement ()
[+] Parser::declarationStatement()
[-] 	result = productionSpecifiers (&specifiers);
[+] 	result = productionSpecifiers(&specifiers);
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 		result = production (&specifiers);
[+] 		result = production(&specifiers);
[-] 	token = expectToken (';');
[+] 	token = expectToken(';');
[-] 	nextToken ();
[+] 	nextToken();
[-] Parser::productionSpecifiers (ProductionSpecifiers* specifiers)
[+] Parser::productionSpecifiers(ProductionSpecifiers* specifiers)
[-] 		const Token* token = getToken ();
[+] 		const Token* token = getToken();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 				err::setError ("multiple class specifiers");
[+] 				err::setError("multiple class specifiers");
[-] 			cls = classSpecifier ();
[+] 			cls = classSpecifier();
[-] 				err::setError ("multiple class specifiers");
[+] 				err::setError("multiple class specifiers");
[-] 			nextToken ();
[+] 			nextToken();
[-] 				err::setError ("multiple class specifiers");
[+] 				err::setError("multiple class specifiers");
[-] 			nextToken ();
[+] 			nextToken();
[-] 				err::setError ("multiple 'pragma' specifiers");
[+] 				err::setError("multiple 'pragma' specifiers");
[-] 			nextToken ();
[+] 			nextToken();
[-] 				err::setError ("multiple 'start' specifiers");
[+] 				err::setError("multiple 'start' specifiers");
[-] 			nextToken ();
[+] 			nextToken();
[-] 				err::setError ("multiple 'nullable' specifiers");
[+] 				err::setError("multiple 'nullable' specifiers");
[-] 			nextToken ();
[+] 			nextToken();
[-] 			laToken = getToken (1);
[+] 			laToken = getToken(1);
[-] 			switch (laToken->m_token)
[+] 			switch(laToken->m_token)
[-] 					err::setError ("multiple class specifiers");
[+] 					err::setError("multiple class specifiers");
[-] 				cls = m_module->m_classMgr.getClass (token->m_data.m_string);
[+] 				cls = m_module->m_classMgr.getClass(token->m_data.m_string);
[-] 				nextToken ();
[+] 				nextToken();
[-] Parser::classSpecifier ()
[+] Parser::classSpecifier()
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	ASSERT (token->m_token == TokenKind_Class);
[+] 	ASSERT(token->m_token == TokenKind_Class);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = getToken ();
[+] 	token = getToken();
[-] 		cls = m_module->m_classMgr.createUnnamedClass ();
[+] 		cls = m_module->m_classMgr.createUnnamedClass();
[-] 		cls = m_module->m_classMgr.getClass (token->m_data.m_string);
[+] 		cls = m_module->m_classMgr.getClass(token->m_data.m_string);
[-] 		nextToken ();
[+] 		nextToken();
[-] 		token = getToken ();
[+] 		token = getToken();
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				cls->m_name.sz ()
[+] 				cls->m_name.sz()
[-] 		nextToken ();
[+] 		nextToken();
[-] 		token = expectToken (TokenKind_Identifier);
[+] 		token = expectToken(TokenKind_Identifier);
[-] 		cls->m_baseClass = m_module->m_classMgr.getClass (token->m_data.m_string);
[+] 		cls->m_baseClass = m_module->m_classMgr.getClass(token->m_data.m_string);
[-] 		nextToken ();
[+] 		nextToken();
[-] 	result = userCode ('{', &cls->m_members, &cls->m_srcPos);
[+] 	result = userCode('{', &cls->m_members, &cls->m_srcPos);
[-] Parser::defineStatement ()
[+] Parser::defineStatement()
[-] 	const Token* token = expectToken (TokenKind_Identifier);
[+] 	const Token* token = expectToken(TokenKind_Identifier);
[-] 	Define* define = m_module->m_defineMgr.getDefine (token->m_data.m_string);
[+] 	Define* define = m_module->m_defineMgr.getDefine(token->m_data.m_string);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = getToken ();
[+] 	token = getToken();
[-] 	switch (token->m_token)
[+] 	switch(token->m_token)
[-] 		return userCode ('{', &define->m_stringValue, &define->m_srcPos);
[+] 		return userCode('{', &define->m_stringValue, &define->m_srcPos);
[-] 		nextToken ();
[+] 		nextToken();
[-] 		token = getToken ();
[+] 		token = getToken();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 			nextToken ();
[+] 			nextToken();
[-] 			nextToken ();
[+] 			nextToken();
[-] 			return userCode ('{', &define->m_stringValue, &define->m_srcPos);
[+] 			return userCode('{', &define->m_stringValue, &define->m_srcPos);
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				define->m_name.sz ()
[+] 				define->m_name.sz()
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			define->m_name.sz ()
[+] 			define->m_name.sz()
[-] 	token = expectToken (';');
[+] 	token = expectToken(';');
[-] 	nextToken ();
[+] 	nextToken();
[-] Parser::usingStatement ()
[+] Parser::usingStatement()
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	ASSERT (token->m_token == TokenKind_Using);
[+] 	ASSERT(token->m_token == TokenKind_Using);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	result = productionSpecifiers (&m_defaultProductionSpecifiers);
[+] 	result = productionSpecifiers(&m_defaultProductionSpecifiers);
[-] Parser::customizeSymbol (SymbolNode* node)
[+] Parser::customizeSymbol(SymbolNode* node)
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 		result = userCode ('<', &node->m_arg, &node->m_argLineCol);
[+] 		result = userCode('<', &node->m_arg, &node->m_argLineCol);
[-] 		token = getToken ();
[+] 		token = getToken();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 		if (!string->isEmpty ())
[+] 		if (!string->isEmpty())
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				node->m_name.sz (),
[+] 				node->m_name.sz(),
[-] 				token->getName ()
[+] 				token->getName()
[-] 		nextToken ();
[+] 		nextToken();
[-] 		result = userCode ('{', string, lineCol);
[+] 		result = userCode('{', string, lineCol);
[-] 	if (!node->m_arg.isEmpty ())
[+] 	if (!node->m_arg.isEmpty())
[-] 		result = processFormalArgList (node);
[+] 		result = processFormalArgList(node);
[-] 	if (!node->m_local.isEmpty ())
[+] 	if (!node->m_local.isEmpty())
[-] 		result = processLocalList (node);
[+] 		result = processLocalList(node);
[-] 	if (!node->m_enter.isEmpty ())
[+] 	if (!node->m_enter.isEmpty())
[-] 		result = processSymbolEventHandler (node, &node->m_enter);
[+] 		result = processSymbolEventHandler(node, &node->m_enter);
[-] 	if (!node->m_leave.isEmpty ())
[+] 	if (!node->m_leave.isEmpty())
[-] 		result = processSymbolEventHandler (node, &node->m_leave);
[+] 		result = processSymbolEventHandler(node, &node->m_leave);
[-] Parser::processFormalArgList (SymbolNode* node)
[+] Parser::processFormalArgList(SymbolNode* node)
[-] 	lexer.create (getMachineState (LexerMachine_UserCode2ndPass), "formal-arg-list", node->m_arg);
[+] 	lexer.create(getMachineState(LexerMachine_UserCode2ndPass), "formal-arg-list", node->m_arg);
[-] 		token = lexer.getToken ();
[+] 		token = lexer.getToken();
[-] 			err::setFormatStringError ("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[+] 			err::setFormatStringError("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 		resultString.append (p, token->m_pos.m_p - p);
[+] 		resultString.append(p, token->m_pos.m_p - p);
[-] 		resultString.append (name);
[+] 		resultString.append(name);
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] 		node->m_argNameList.insertTail (name);
[+] 		node->m_argNameList.insertTail(name);
[-] 		node->m_argNameSet.visit (name);
[+] 		node->m_argNameSet.visit(name);
[-] 		token = lexer.getToken ();
[+] 		token = lexer.getToken();
[-] 		token = lexer.expectToken (',');
[+] 		token = lexer.expectToken(',');
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] 	ASSERT (!token->m_token);
[+] 	ASSERT(!token->m_token);
[-] 	resultString.append (p, token->m_pos.m_p - p);
[+] 	resultString.append(p, token->m_pos.m_p - p);
[-] Parser::processLocalList (SymbolNode* node)
[+] Parser::processLocalList(SymbolNode* node)
[-] 	lexer.create (getMachineState (LexerMachine_UserCode2ndPass), "local-list", node->m_local);
[+] 	lexer.create(getMachineState(LexerMachine_UserCode2ndPass), "local-list", node->m_local);
[-] 		token = lexer.getToken ();
[+] 		token = lexer.getToken();
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 		resultString.append (p, token->m_pos.m_p - p);
[+] 		resultString.append(p, token->m_pos.m_p - p);
[-] 		resultString.append (name);
[+] 		resultString.append(name);
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] 		node->m_localNameList.insertTail (name);
[+] 		node->m_localNameList.insertTail(name);
[-] 		node->m_localNameSet.visit (name);
[+] 		node->m_localNameSet.visit(name);
[-] 	ASSERT (!token->m_token);
[+] 	ASSERT(!token->m_token);
[-] 	resultString.append (p, token->m_pos.m_p - p);
[+] 	resultString.append(p, token->m_pos.m_p - p);
[-] Parser::processSymbolEventHandler (
[+] Parser::processSymbolEventHandler(
[-] 	lexer.create (getMachineState (LexerMachine_UserCode2ndPass), "event-handler", *string);
[+] 	lexer.create(getMachineState(LexerMachine_UserCode2ndPass), "event-handler", *string);
[-] 		token = lexer.getToken ();
[+] 		token = lexer.getToken();
[-] 		sl::StringHashTableIterator <bool> it;
[+] 		sl::StringHashTableIterator<bool> it;
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 			it = node->m_localNameSet.find (token->m_data.m_string);
[+] 			it = node->m_localNameSet.find(token->m_data.m_string);
[-] 				resultString.append (p, token->m_pos.m_p - p);
[+] 				resultString.append(p, token->m_pos.m_p - p);
[-] 				resultString.appendFormat (
[+] 				resultString.appendFormat(
[-] 					token->m_data.m_string.sz ()
[+] 					token->m_data.m_string.sz()
[-] 			it = node->m_argNameSet.find (token->m_data.m_string);
[+] 			it = node->m_argNameSet.find(token->m_data.m_string);
[-] 				resultString.append (p, token->m_pos.m_p - p);
[+] 				resultString.append(p, token->m_pos.m_p - p);
[-] 				resultString.appendFormat (
[+] 				resultString.appendFormat(
[-] 					token->m_data.m_string.sz ()
[+] 					token->m_data.m_string.sz()
[-] 			err::setFormatStringError ("undeclared identifier '%s'", token->m_data.m_string.sz ());
[+] 			err::setFormatStringError("undeclared identifier '%s'", token->m_data.m_string.sz ());
[-] 				err::setFormatStringError ("'enter' or 'leave' cannot have indexed references");
[+] 				err::setFormatStringError("'enter' or 'leave' cannot have indexed references");
[-] 			resultString.append (p, token->m_pos.m_p - p);
[+] 			resultString.append(p, token->m_pos.m_p - p);
[-] 			resultString.append ('$');
[+] 			resultString.append('$');
[-] 			lexer.nextToken ();
[+] 			lexer.nextToken();
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] 	ASSERT (!token->m_token);
[+] 	ASSERT(!token->m_token);
[-] 	resultString.append (p, token->m_pos.m_p - p);
[+] 	resultString.append(p, token->m_pos.m_p - p);
[-] Parser::processActualArgList (
[+] Parser::processActualArgList(
[-] 	lexer.create (getMachineState (LexerMachine_UserCode2ndPass), "actual-arg-list", string);
[+] 	lexer.create(getMachineState(LexerMachine_UserCode2ndPass), "actual-arg-list", string);
[-] 	const char* p = string.cp ();
[+] 	const char* p = string.cp();
[-] 		token = lexer.getToken ();
[+] 		token = lexer.getToken();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 				sl::String valueString (p, token->m_pos.m_p - p);
[+] 				sl::String valueString(p, token->m_pos.m_p - p);
[-] 				node->m_argValueList.insertTail (valueString);
[+] 				node->m_argValueList.insertTail(valueString);
[-] 		lexer.nextToken ();
[+] 		lexer.nextToken();
[-] 	sl::String valueString (p, token->m_pos.m_p - p);
[+] 	sl::String valueString(p, token->m_pos.m_p - p);
[-] 	node->m_argValueList.insertTail (valueString);
[+] 	node->m_argValueList.insertTail(valueString);
[-] 	ASSERT (!token->m_token);
[+] 	ASSERT(!token->m_token);
[-] Parser::setGrammarNodeSrcPos (
[+] Parser::setGrammarNodeSrcPos(
[-] Parser::production (const ProductionSpecifiers* specifiers)
[+] Parser::production(const ProductionSpecifiers* specifiers)
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	ASSERT (token->m_token == TokenKind_Identifier);
[+] 	ASSERT(token->m_token == TokenKind_Identifier);
[-] 	SymbolNode* symbol = m_module->m_nodeMgr.getSymbolNode (token->m_data.m_string);
[+] 	SymbolNode* symbol = m_module->m_nodeMgr.getSymbolNode(token->m_data.m_string);
[-] 	if (!symbol->m_productionArray.isEmpty ())
[+] 	if (!symbol->m_productionArray.isEmpty())
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] 			symbol->m_name.sz ()
[+] 			symbol->m_name.sz()
[-] 	setGrammarNodeSrcPos (symbol);
[+] 	setGrammarNodeSrcPos(symbol);
[-] 	nextToken ();
[+] 	nextToken();
[-] 		m_module->m_nodeMgr.m_startPragmaSymbol.m_productionArray.append (symbol);
[+] 		m_module->m_nodeMgr.m_startPragmaSymbol.m_productionArray.append(symbol);
[-] 	result = customizeSymbol (symbol);
[+] 	result = customizeSymbol(symbol);
[-] 	token = expectToken (':');
[+] 	token = expectToken(':');
[-] 	nextToken ();
[+] 	nextToken();
[-] 	GrammarNode* rightSide = alternative ();
[+] 	GrammarNode* rightSide = alternative();
[-] 	symbol->addProduction (rightSide);
[+] 	symbol->addProduction(rightSide);
[-] Parser::alternative ()
[+] Parser::alternative()
[-] 	GrammarNode* node = sequence ();
[+] 	GrammarNode* node = sequence();
[-] 		const Token* token = getToken ();
[+] 		const Token* token = getToken();
[-] 		nextToken ();
[+] 		nextToken();
[-] 		GrammarNode* node2 = sequence ();
[+] 		GrammarNode* node2 = sequence();
[-] 				temp = (SymbolNode*) node;
[+] 				temp = (SymbolNode*)node;
[-] 				temp = m_module->m_nodeMgr.createTempSymbolNode ();
[+] 				temp = m_module->m_nodeMgr.createTempSymbolNode();
[-] 				temp->addProduction (node);
[+] 				temp->addProduction(node);
[-] 				setGrammarNodeSrcPos (temp, node->m_srcPos);
[+] 				setGrammarNodeSrcPos(temp, node->m_srcPos);
[-] 		temp->addProduction (node2);
[+] 		temp->addProduction(node2);
[-] isFirstOfPrimary (int token)
[+] isFirstOfPrimary(int token)
[-] 	switch (token)
[+] 	switch(token)
[-] Parser::sequence ()
[+] Parser::sequence()
[-] 	GrammarNode* node = quantifier ();
[+] 	GrammarNode* node = quantifier();
[-] 		const Token* token = getToken ();
[+] 		const Token* token = getToken();
[-] 		if (!isFirstOfPrimary (token->m_token))
[+] 		if (!isFirstOfPrimary(token->m_token))
[-] 		GrammarNode* node2 = quantifier ();
[+] 		GrammarNode* node2 = quantifier();
[-] 				temp = (SequenceNode*) node;
[+] 				temp = (SequenceNode*)node;
[-] 				temp = m_module->m_nodeMgr.createSequenceNode ();
[+] 				temp = m_module->m_nodeMgr.createSequenceNode();
[-] 				temp->append (node);
[+] 				temp->append(node);
[-] 				setGrammarNodeSrcPos (temp, node->m_srcPos);
[+] 				setGrammarNodeSrcPos(temp, node->m_srcPos);
[-] 		temp->append (node2);
[+] 		temp->append(node2);
[-] Parser::quantifier ()
[+] Parser::quantifier()
[-] 	GrammarNode* node = primary ();
[+] 	GrammarNode* node = primary();
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	GrammarNode* temp = m_module->m_nodeMgr.createQuantifierNode (node, token->m_token);
[+] 	GrammarNode* temp = m_module->m_nodeMgr.createQuantifierNode(node, token->m_token);
[-] 	setGrammarNodeSrcPos (temp, node->m_srcPos);
[+] 	setGrammarNodeSrcPos(temp, node->m_srcPos);
[-] 	nextToken ();
[+] 	nextToken();
[-] Parser::primary ()
[+] Parser::primary()
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	switch (token->m_token)
[+] 	switch(token->m_token)
[-] 		node = beacon ();
[+] 		node = beacon();
[-] 		nextToken ();
[+] 		nextToken();
[-] 		node = beacon ();
[+] 		node = beacon();
[-] 		token = getToken ();
[+] 		token = getToken();
[-] 			BeaconNode* beacon = (BeaconNode*) node;
[+] 			BeaconNode* beacon = (BeaconNode*)node;
[-] 			ArgumentNode* argument = m_module->m_nodeMgr.createArgumentNode ();
[+] 			ArgumentNode* argument = m_module->m_nodeMgr.createArgumentNode();
[-] 			SequenceNode* sequence = m_module->m_nodeMgr.createSequenceNode ();
[+] 			SequenceNode* sequence = m_module->m_nodeMgr.createSequenceNode();
[-] 			setGrammarNodeSrcPos (sequence, node->m_srcPos);
[+] 			setGrammarNodeSrcPos(sequence, node->m_srcPos);
[-] 			result = userCode ('<', &string, &argument->m_srcPos);
[+] 			result = userCode('<', &string, &argument->m_srcPos);
[-] 			result = processActualArgList (argument, string);
[+] 			result = processActualArgList(argument, string);
[-] 			sequence->append (beacon);
[+] 			sequence->append(beacon);
[-] 			sequence->append (argument);
[+] 			sequence->append(argument);
[-] 		actionNode = m_module->m_nodeMgr.createActionNode ();
[+] 		actionNode = m_module->m_nodeMgr.createActionNode();
[-] 		result = userCode ('{', &actionNode->m_userCode, &actionNode->m_srcPos);
[+] 		result = userCode('{', &actionNode->m_userCode, &actionNode->m_srcPos);
[-] 		node = resolver ();
[+] 		node = resolver();
[-] 		nextToken ();
[+] 		nextToken();
[-] 		node = alternative ();
[+] 		node = alternative();
[-] 		token = expectToken (')');
[+] 		token = expectToken(')');
[-] 		nextToken ();
[+] 		nextToken();
[-] 		lex::setUnexpectedTokenError (token->getName (), "primary");
[+] 		lex::setUnexpectedTokenError(token->getName(), "primary");
[-] Parser::beacon ()
[+] Parser::beacon()
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	switch (token->m_token)
[+] 	switch(token->m_token)
[-] 		node = m_module->m_nodeMgr.getSymbolNode (token->m_data.m_string);
[+] 		node = m_module->m_nodeMgr.getSymbolNode(token->m_data.m_string);
[-] 			err::setFormatStringError ("cannot use a reserved eof token \\00");
[+] 			err::setFormatStringError("cannot use a reserved eof token \\00");
[-] 		node = m_module->m_nodeMgr.getTokenNode (token->m_data.m_integer);
[+] 		node = m_module->m_nodeMgr.getTokenNode(token->m_data.m_integer);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	BeaconNode* beacon = m_module->m_nodeMgr.createBeaconNode (node);
[+] 	BeaconNode* beacon = m_module->m_nodeMgr.createBeaconNode(node);
[-] 	setGrammarNodeSrcPos (beacon);
[+] 	setGrammarNodeSrcPos(beacon);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = getToken ();
[+] 	token = getToken();
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = expectToken (TokenKind_Identifier);
[+] 	token = expectToken(TokenKind_Identifier);
[-] 	nextToken ();
[+] 	nextToken();
[-] Parser::resolver ()
[+] Parser::resolver()
[-] 	const Token* token = getToken ();
[+] 	const Token* token = getToken();
[-] 	ASSERT (token->m_token == TokenKind_Resolver);
[+] 	ASSERT(token->m_token == TokenKind_Resolver);
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = expectToken ('(');
[+] 	token = expectToken('(');
[-] 	nextToken ();
[+] 	nextToken();
[-] 	GrammarNode* resolver = alternative ();
[+] 	GrammarNode* resolver = alternative();
[-] 	token = expectToken (')');
[+] 	token = expectToken(')');
[-] 	nextToken ();
[+] 	nextToken();
[-] 	token = getToken ();
[+] 	token = getToken();
[-] 		nextToken ();
[+] 		nextToken();
[-] 		token = expectToken ('(');
[+] 		token = expectToken('(');
[-] 		nextToken ();
[+] 		nextToken();
[-] 		token = expectToken (TokenKind_Integer);
[+] 		token = expectToken(TokenKind_Integer);
[-] 		nextToken ();
[+] 		nextToken();
[-] 		token = expectToken (')');
[+] 		token = expectToken(')');
[-] 		nextToken ();
[+] 		nextToken();
[-] 	GrammarNode* production = sequence ();
[+] 	GrammarNode* production = sequence();
[-] 	SymbolNode* temp = m_module->m_nodeMgr.createTempSymbolNode ();
[+] 	SymbolNode* temp = m_module->m_nodeMgr.createTempSymbolNode();
[-] 	temp->addProduction (production);
[+] 	temp->addProduction(production);
[-] 	setGrammarNodeSrcPos (temp, pos);
[+] 	setGrammarNodeSrcPos(temp, pos);
[-] Parser::userCode (
[+] Parser::userCode(
[-] 	bool result = userCode (openBracket, string, (lex::LineCol*) srcPos);
[+] 	bool result = userCode(openBracket, string, (lex::LineCol*)srcPos);
[-] Parser::userCode (
[+] Parser::userCode(
[-] 	const Token* token = expectToken (openBracket);
[+] 	const Token* token = expectToken(openBracket);
[-] 	gotoState (getMachineState (LexerMachine_UserCode), token, GotoStateKind_ReparseToken);
[+] 	gotoState(getMachineState(LexerMachine_UserCode), token, GotoStateKind_ReparseToken);
[-] 	token = getToken ();
[+] 	token = getToken();
[-] 	switch (openBracket)
[+] 	switch(openBracket)
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 		err::setFormatStringError ("invalid user code opener '%s'", Token::getName (openBracket));
[+] 		err::setFormatStringError("invalid user code opener '%s'", Token::getName (openBracket));
[-] 	nextToken ();
[+] 	nextToken();
[-] 		token = getToken ();
[+] 		token = getToken();
[-] 			lex::setUnexpectedTokenError ("eof", "user-code");
[+] 			lex::setUnexpectedTokenError("eof", "user-code");
[-] 			err::setFormatStringError ("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[+] 			err::setFormatStringError("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[-] 		nextToken ();
[+] 		nextToken();
[-] 	token = getToken ();
[+] 	token = getToken();
[-] 	ASSERT (token->m_token == closeBracket);
[+] 	ASSERT(token->m_token == closeBracket);
[-] 	*string = sl::String (begin, token->m_pos.m_p - begin);
[+] 	*string = sl::String(begin, token->m_pos.m_p - begin);
[-] 	gotoState (getMachineState (LexerMachine_Main), token, GotoStateKind_EatToken);
[+] 	gotoState(getMachineState(LexerMachine_Main), token, GotoStateKind_EatToken);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\ParseTableBuilder.cpp
----------------------
[-] ParseTableBuilder::build ()
[+] ParseTableBuilder::build()
[-] 	calcFirstFollow ();
[+] 	calcFirstFollow();
[-] 	size_t symbolCount = m_nodeMgr->m_symbolArray.getCount ();
[+] 	size_t symbolCount = m_nodeMgr->m_symbolArray.getCount();
[-] 	size_t terminalCount = m_nodeMgr->m_tokenArray.getCount ();
[+] 	size_t terminalCount = m_nodeMgr->m_tokenArray.getCount();
[-] 	m_parseTable->setCountZeroConstruct (symbolCount * terminalCount);
[+] 	m_parseTable->setCountZeroConstruct(symbolCount * terminalCount);
[-] 		SymbolNode* node = m_nodeMgr->m_symbolArray [i];
[+] 		SymbolNode* node = m_nodeMgr->m_symbolArray[i];
[-] 			if (node->isNullable () && !(node->m_flags & SymbolNodeFlag_Nullable))
[+] 			if (node->isNullable() && !(node->m_flags & SymbolNodeFlag_Nullable))
[-] 				err::setFormatStringError (
[+] 				err::setFormatStringError(
[-] 					node->m_name.sz ()
[+] 					node->m_name.sz()
[-] 				lex::pushSrcPosError (node->m_srcPos);
[+] 				lex::pushSrcPosError(node->m_srcPos);
[-] 			if (!node->isNullable () && (node->m_flags & SymbolNodeFlag_Nullable))
[+] 			if (!node->isNullable() && (node->m_flags & SymbolNodeFlag_Nullable))
[-] 				err::setFormatStringError (
[+] 				err::setFormatStringError(
[-] 					node->m_name.sz ()
[+] 					node->m_name.sz()
[-] 				lex::pushSrcPosError (node->m_srcPos);
[+] 				lex::pushSrcPosError(node->m_srcPos);
[-] 			if (node->isNullable ())
[+] 			if (node->isNullable())
[-] 				err::setFormatStringError (
[+] 				err::setFormatStringError(
[-] 					node->m_name.sz ()
[+] 					node->m_name.sz()
[-] 				lex::pushSrcPosError (node->m_srcPos);
[+] 				lex::pushSrcPosError(node->m_srcPos);
[-] 			if (node->m_firstSet.getBit (1))
[+] 			if (node->m_firstSet.getBit(1))
[-] 				err::setFormatStringError (
[+] 				err::setFormatStringError(
[-] 					node->m_name.sz ()
[+] 					node->m_name.sz()
[-] 				lex::pushSrcPosError (node->m_srcPos);
[+] 				lex::pushSrcPosError(node->m_srcPos);
[-] 		size_t childrenCount = node->m_productionArray.getCount ();
[+] 		size_t childrenCount = node->m_productionArray.getCount();
[-] 			GrammarNode* production = node->m_productionArray [j];
[+] 			GrammarNode* production = node->m_productionArray[j];
[-] 			addProductionToParseTable (node, production);
[+] 			addProductionToParseTable(node, production);
[-] 		SymbolNode* node = m_nodeMgr->m_symbolArray [i];
[+] 		SymbolNode* node = m_nodeMgr->m_symbolArray[i];
[-] 		size_t childrenCount = node->m_productionArray.getCount ();
[+] 		size_t childrenCount = node->m_productionArray.getCount();
[-] 			GrammarNode* production = node->m_productionArray [j];
[+] 			GrammarNode* production = node->m_productionArray[j];
[-] 			if (production->m_firstSet.getBit (1) || (production->isNullable () && node->m_followSet.getBit (1)))
[+] 			if (production->m_firstSet.getBit(1) || (production->isNullable() && node->m_followSet.getBit(1)))
[-] 				addAnyTokenProductionToParseTable (node, production);
[+] 				addAnyTokenProductionToParseTable(node, production);
[-] ParseTableBuilder::addProductionToParseTable (
[+] ParseTableBuilder::addProductionToParseTable(
[-] 	count = production->m_firstArray.getCount ();
[+] 	count = production->m_firstArray.getCount();
[-] 		SymbolNode* token = production->m_firstArray [i];
[+] 		SymbolNode* token = production->m_firstArray[i];
[-] 		addParseTableEntry (symbol, token, production);
[+] 		addParseTableEntry(symbol, token, production);
[-] 	if (!production->isNullable ())
[+] 	if (!production->isNullable())
[-] 	count = symbol->m_followArray.getCount ();
[+] 	count = symbol->m_followArray.getCount();
[-] 		SymbolNode* token = symbol->m_followArray [i];
[+] 		SymbolNode* token = symbol->m_followArray[i];
[-] 		addParseTableEntry (symbol, token, production);
[+] 		addParseTableEntry(symbol, token, production);
[-] 	if (symbol->isFinal ())
[+] 	if (symbol->isFinal())
[-] 		addParseTableEntry (symbol, &m_nodeMgr->m_eofTokenNode, production);
[+] 		addParseTableEntry(symbol, &m_nodeMgr->m_eofTokenNode, production);
[-] ParseTableBuilder::addAnyTokenProductionToParseTable (
[+] ParseTableBuilder::addAnyTokenProductionToParseTable(
[-] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount ();
[+] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount();
[-] 		SymbolNode* token = m_nodeMgr->m_tokenArray [i];
[+] 		SymbolNode* token = m_nodeMgr->m_tokenArray[i];
[-] 		addParseTableEntry (symbol, token, production);
[+] 		addParseTableEntry(symbol, token, production);
[-] ParseTableBuilder::addParseTableEntry (
[+] ParseTableBuilder::addParseTableEntry(
[-] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount ();
[+] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount();
[-] 		conflict = m_nodeMgr->createConflictNode ();
[+] 		conflict = m_nodeMgr->createConflictNode();
[-] 		conflict->m_productionArray.setCount (2);
[+] 		conflict->m_productionArray.setCount(2);
[-] 		conflict->m_productionArray [0] = (GrammarNode*) oldProduction;
[+] 		conflict->m_productionArray[0] = (GrammarNode*)oldProduction;
[-] 		conflict->m_productionArray [1] = production;
[+] 		conflict->m_productionArray[1] = production;
[-] 		conflict = (ConflictNode*) oldProduction;
[+] 		conflict = (ConflictNode*)oldProduction;
[-] 		size_t count = conflict->m_productionArray.getCount ();
[+] 		size_t count = conflict->m_productionArray.getCount();
[-] 			if (conflict->m_productionArray [i] == production)
[+] 			if (conflict->m_productionArray[i] == production)
[-] 			conflict->m_productionArray.append (production);
[+] 			conflict->m_productionArray.append(production);
[-] 	return conflict->m_productionArray.getCount ();
[+] 	return conflict->m_productionArray.getCount();
[-] propagateParentChild (
[+] propagateParentChild(
[-] 	if (parent->m_firstSet.merge (child->m_firstSet, sl::BitOpKind_Or))
[+] 	if (parent->m_firstSet.merge(child->m_firstSet, sl::BitOpKind_Or))
[-] 	if (child->m_followSet.merge (parent->m_followSet, sl::BitOpKind_Or))
[+] 	if (child->m_followSet.merge(parent->m_followSet, sl::BitOpKind_Or))
[-] 	if (child->isNullable ())
[+] 	if (child->isNullable())
[-] 		if (parent->markNullable ())
[+] 		if (parent->markNullable())
[-] 	if (parent->isFinal ())
[+] 	if (parent->isFinal())
[-] 		if (child->markFinal ())
[+] 		if (child->markFinal())
[-] ParseTableBuilder::calcFirstFollow ()
[+] ParseTableBuilder::calcFirstFollow()
[-] 	GrammarNode* startSymbol = m_nodeMgr->m_symbolArray [0];
[+] 	GrammarNode* startSymbol = m_nodeMgr->m_symbolArray[0];
[-] 	startSymbol->markFinal ();
[+] 	startSymbol->markFinal();
[-] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount ();
[+] 	size_t tokenCount = m_nodeMgr->m_tokenArray.getCount();
[-] 	size_t symbolCount = m_nodeMgr->m_symbolArray.getCount ();
[+] 	size_t symbolCount = m_nodeMgr->m_symbolArray.getCount();
[-] 		SymbolNode* node = m_nodeMgr->m_tokenArray [i];
[+] 		SymbolNode* node = m_nodeMgr->m_tokenArray[i];
[-] 		node->m_firstSet.setBitResize (node->m_masterIndex, true);
[+] 		node->m_firstSet.setBitResize(node->m_masterIndex, true);
[-] 		SymbolNode* node = m_nodeMgr->m_symbolArray [i];
[+] 		SymbolNode* node = m_nodeMgr->m_symbolArray[i];
[-] 		node->m_firstSet.setBitCount (tokenCount);
[+] 		node->m_firstSet.setBitCount(tokenCount);
[-] 		node->m_followSet.setBitCount (tokenCount);
[+] 		node->m_followSet.setBitCount(tokenCount);
[-] 			node->m_resolver->m_followSet.setBitResize (1); // set anytoken FOLLOW for resolver
[+] 			node->m_resolver->m_followSet.setBitResize(1); // set anytoken FOLLOW for resolver
[-] 			node->markFinal ();
[+] 			node->markFinal();
[-] 	sl::Iterator <SequenceNode> sequence = m_nodeMgr->m_sequenceList.getHead ();
[+] 	sl::Iterator<SequenceNode> sequence = m_nodeMgr->m_sequenceList.getHead();
[-] 		sequence->m_firstSet.setBitCount (tokenCount);
[+] 		sequence->m_firstSet.setBitCount(tokenCount);
[-] 		sequence->m_followSet.setBitCount (tokenCount);
[+] 		sequence->m_followSet.setBitCount(tokenCount);
[-] 	sl::Iterator <BeaconNode> beacon = m_nodeMgr->m_beaconList.getHead ();
[+] 	sl::Iterator<BeaconNode> beacon = m_nodeMgr->m_beaconList.getHead();
[-] 		beacon->m_firstSet.setBitCount (tokenCount);
[+] 		beacon->m_firstSet.setBitCount(tokenCount);
[-] 		beacon->m_followSet.setBitCount (tokenCount);
[+] 		beacon->m_followSet.setBitCount(tokenCount);
[-] 			SymbolNode* node = m_nodeMgr->m_symbolArray [i];
[+] 			SymbolNode* node = m_nodeMgr->m_symbolArray[i];
[-] 			size_t childrenCount = node->m_productionArray.getCount ();
[+] 			size_t childrenCount = node->m_productionArray.getCount();
[-] 				GrammarNode* production = node->m_productionArray [j];
[+] 				GrammarNode* production = node->m_productionArray[j];
[-] 				if (propagateParentChild (node, production))
[+] 				if (propagateParentChild(node, production))
[-] 		sequence = m_nodeMgr->m_sequenceList.getHead ();
[+] 		sequence = m_nodeMgr->m_sequenceList.getHead();
[-] 			size_t childrenCount = node->m_sequence.getCount ();
[+] 			size_t childrenCount = node->m_sequence.getCount();
[-] 				GrammarNode* child = node->m_sequence [j];
[+] 				GrammarNode* child = node->m_sequence[j];
[-] 				if (node->m_firstSet.merge (child->m_firstSet, sl::BitOpKind_Or))
[+] 				if (node->m_firstSet.merge(child->m_firstSet, sl::BitOpKind_Or))
[-] 				if (!child->isNullable ())
[+] 				if (!child->isNullable())
[-] 				if (node->markNullable ())
[+] 				if (node->markNullable())
[-] 				GrammarNode* child = node->m_sequence [j];
[+] 				GrammarNode* child = node->m_sequence[j];
[-] 				if (child->m_followSet.merge (node->m_followSet, sl::BitOpKind_Or))
[+] 				if (child->m_followSet.merge(node->m_followSet, sl::BitOpKind_Or))
[-] 				if (node->isFinal ())
[+] 				if (node->isFinal())
[-] 					if (child->markFinal ())
[+] 					if (child->markFinal())
[-] 				if (!child->isNullable ())
[+] 				if (!child->isNullable())
[-] 					GrammarNode* child = node->m_sequence [j];
[+] 					GrammarNode* child = node->m_sequence[j];
[-] 						GrammarNode* next = node->m_sequence [k];
[+] 						GrammarNode* next = node->m_sequence[k];
[-] 						if (child->m_followSet.merge (next->m_firstSet, sl::BitOpKind_Or))
[+] 						if (child->m_followSet.merge(next->m_firstSet, sl::BitOpKind_Or))
[-] 						if (!next->isNullable ())
[+] 						if (!next->isNullable())
[-] 		beacon = m_nodeMgr->m_beaconList.getHead ();
[+] 		beacon = m_nodeMgr->m_beaconList.getHead();
[-] 			if (propagateParentChild (*beacon, beacon->m_target))
[+] 			if (propagateParentChild(*beacon, beacon->m_target))
[-] 	buildFirstFollowArrays (&m_nodeMgr->m_anyTokenNode);
[+] 	buildFirstFollowArrays(&m_nodeMgr->m_anyTokenNode);
[-] 		SymbolNode* node = m_nodeMgr->m_tokenArray [i];
[+] 		SymbolNode* node = m_nodeMgr->m_tokenArray[i];
[-] 		buildFirstFollowArrays (node);
[+] 		buildFirstFollowArrays(node);
[-] 		SymbolNode* node = m_nodeMgr->m_symbolArray [i];
[+] 		SymbolNode* node = m_nodeMgr->m_symbolArray[i];
[-] 		buildFirstFollowArrays (node);
[+] 		buildFirstFollowArrays(node);
[-] 	sequence = m_nodeMgr->m_sequenceList.getHead ();
[+] 	sequence = m_nodeMgr->m_sequenceList.getHead();
[-] 		buildFirstFollowArrays (*sequence);
[+] 		buildFirstFollowArrays(*sequence);
[-] 	beacon = m_nodeMgr->m_beaconList.getHead ();
[+] 	beacon = m_nodeMgr->m_beaconList.getHead();
[-] 		buildFirstFollowArrays (*beacon);
[+] 		buildFirstFollowArrays(*beacon);
[-] ParseTableBuilder::buildFirstFollowArrays (GrammarNode* node)
[+] ParseTableBuilder::buildFirstFollowArrays(GrammarNode* node)
[-] 	node->m_firstArray.clear ();
[+] 	node->m_firstArray.clear();
[-] 	node->m_followArray.clear ();
[+] 	node->m_followArray.clear();
[-] 		size_t i = node->m_firstSet.findBit (0);
[+] 		size_t i = node->m_firstSet.findBit(0);
[-] 		i = node->m_firstSet.findBit (i + 1)
[+] 		i = node->m_firstSet.findBit(i + 1)
[-] 		SymbolNode* token = m_nodeMgr->m_tokenArray [i];
[+] 		SymbolNode* token = m_nodeMgr->m_tokenArray[i];
[-] 		node->m_firstArray.append (token);
[+] 		node->m_firstArray.append(token);
[-] 		size_t i = node->m_followSet.findBit (0);
[+] 		size_t i = node->m_followSet.findBit(0);
[-] 		i = node->m_followSet.findBit (i + 1)
[+] 		i = node->m_followSet.findBit(i + 1)
[-] 		SymbolNode* token = m_nodeMgr->m_tokenArray [i];
[+] 		SymbolNode* token = m_nodeMgr->m_tokenArray[i];
[-] 		node->m_followArray.append (token);
[+] 		node->m_followArray.append(token);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\ProductionBuilder.cpp
----------------------
[-] ProductionBuilder::ProductionBuilder (NodeMgr* nodeMgr)
[+] ProductionBuilder::ProductionBuilder(NodeMgr* nodeMgr)
[-] ProductionBuilder::build (
[+] ProductionBuilder::build(
[-] 	switch (production->m_kind)
[+] 	switch(production->m_kind)
[-] 		beacon = (BeaconNode*) production;
[+] 		beacon = (BeaconNode*)production;
[-] 		formalArgCount = beacon->m_target->m_argNameList.getCount ();
[+] 		formalArgCount = beacon->m_target->m_argNameList.getCount();
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				beacon->m_target->m_name.sz (),
[+] 				beacon->m_target->m_name.sz(),
[-] 			lex::pushSrcPosError (beacon->m_srcPos);
[+] 			lex::pushSrcPosError(beacon->m_srcPos);
[-] 		m_nodeMgr->deleteBeaconNode (beacon);
[+] 		m_nodeMgr->deleteBeaconNode(beacon);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	m_actionArray.clear ();
[+] 	m_actionArray.clear();
[-] 	m_argumentArray.clear ();
[+] 	m_argumentArray.clear();
[-] 	m_beaconArray.clear ();
[+] 	m_beaconArray.clear();
[-] 	m_beaconDeleteArray.clear ();
[+] 	m_beaconDeleteArray.clear();
[-] 	m_beaconMap.clear ();
[+] 	m_beaconMap.clear();
[-] 	result = scan (production);
[+] 	result = scan(production);
[-] 	result = processAllUserCode ();
[+] 	result = processAllUserCode();
[-] 		ensureSrcPosError ();
[+] 		ensureSrcPosError();
[-] 	findAndReplaceUnusedBeacons (production);
[+] 	findAndReplaceUnusedBeacons(production);
[-] 	size_t count = m_beaconDeleteArray.getCount ();
[+] 	size_t count = m_beaconDeleteArray.getCount();
[-] 		m_nodeMgr->deleteBeaconNode (m_beaconDeleteArray [i]);
[+] 		m_nodeMgr->deleteBeaconNode(m_beaconDeleteArray[i]);
[-] ProductionBuilder::processAllUserCode ()
[+] ProductionBuilder::processAllUserCode()
[-] 	size_t count = m_actionArray.getCount ();
[+] 	size_t count = m_actionArray.getCount();
[-] 		ActionNode* node = m_actionArray [i];
[+] 		ActionNode* node = m_actionArray[i];
[-] 		result = processUserCode (node->m_srcPos, &node->m_userCode, node->m_resolver);
[+] 		result = processUserCode(node->m_srcPos, &node->m_userCode, node->m_resolver);
[-] 	count = m_argumentArray.getCount ();
[+] 	count = m_argumentArray.getCount();
[-] 		ArgumentNode* node = m_argumentArray [i];
[+] 		ArgumentNode* node = m_argumentArray[i];
[-] 		sl::BoxIterator <sl::String> it = node->m_argValueList.getHead ();
[+] 		sl::BoxIterator<sl::String> it = node->m_argValueList.getHead();
[-] 			result = processUserCode (node->m_srcPos, &*it, node->m_resolver);
[+] 			result = processUserCode(node->m_srcPos, &*it, node->m_resolver);
[-] ProductionBuilder::scan (GrammarNode* node)
[+] ProductionBuilder::scan(GrammarNode* node)
[-] 	switch (node->m_kind)
[+] 	switch(node->m_kind)
[-] 		symbol = (SymbolNode*) node;
[+] 		symbol = (SymbolNode*)node;
[-] 			result = scan (symbol->m_resolver);
[+] 			result = scan(symbol->m_resolver);
[-] 		childrenCount = symbol->m_productionArray.getCount ();
[+] 		childrenCount = symbol->m_productionArray.getCount();
[-] 			GrammarNode* child = symbol->m_productionArray [i];
[+] 			GrammarNode* child = symbol->m_productionArray[i];
[-] 			result = scan (child);
[+] 			result = scan(child);
[-] 		sequence = (SequenceNode*) node;
[+] 		sequence = (SequenceNode*)node;
[-] 		childrenCount = sequence->m_sequence.getCount ();
[+] 		childrenCount = sequence->m_sequence.getCount();
[-] 			GrammarNode* child = sequence->m_sequence [i];
[+] 			GrammarNode* child = sequence->m_sequence[i];
[-] 			result = scan (child);
[+] 			result = scan(child);
[-] 		result = addBeacon ((BeaconNode*) node);
[+] 		result = addBeacon((BeaconNode*)node);
[-] 		action = (ActionNode*) node;
[+] 		action = (ActionNode*)node;
[-] 		m_actionArray.append (action);
[+] 		m_actionArray.append(action);
[-] 		argument = (ArgumentNode*) node;
[+] 		argument = (ArgumentNode*)node;
[-] 		m_argumentArray.append (argument);
[+] 		m_argumentArray.append(argument);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] ProductionBuilder::addBeacon (BeaconNode* beacon)
[+] ProductionBuilder::addBeacon(BeaconNode* beacon)
[-] 	if (!beacon->m_label.isEmpty ())
[+] 	if (!beacon->m_label.isEmpty())
[-] 		sl::StringHashTableIterator <BeaconNode*> it = m_beaconMap.visit (beacon->m_label);
[+] 		sl::StringHashTableIterator<BeaconNode*> it = m_beaconMap.visit(beacon->m_label);
[-] 		SymbolNode* node = (SymbolNode*) beacon->m_target;
[+] 		SymbolNode* node = (SymbolNode*)beacon->m_target;
[-] 		size_t formalArgCount = node->m_argNameList.getCount ();
[+] 		size_t formalArgCount = node->m_argNameList.getCount();
[-] 		size_t actualArgCount = beacon->m_argument ? beacon->m_argument->m_argValueList.getCount () : 0;
[+] 		size_t actualArgCount = beacon->m_argument ? beacon->m_argument->m_argValueList.getCount() : 0;
[-] 			err::setFormatStringError (
[+] 			err::setFormatStringError(
[-] 				node->m_name.sz (),
[+] 				node->m_name.sz(),
[-] 			lex::pushSrcPosError (beacon->m_srcPos);
[+] 			lex::pushSrcPosError(beacon->m_srcPos);
[-] 	m_beaconArray.append (beacon);
[+] 	m_beaconArray.append(beacon);
[-] ProductionBuilder::findAndReplaceUnusedBeacons (GrammarNode*& node)
[+] ProductionBuilder::findAndReplaceUnusedBeacons(GrammarNode*& node)
[-] 	switch (node->m_kind)
[+] 	switch(node->m_kind)
[-] 		beacon = (BeaconNode*) node;
[+] 		beacon = (BeaconNode*)node;
[-] 			m_beaconDeleteArray.append (beacon);
[+] 			m_beaconDeleteArray.append(beacon);
[-] 		symbol = (SymbolNode*) node;
[+] 		symbol = (SymbolNode*)node;
[-] 			findAndReplaceUnusedBeacons (symbol->m_resolver);
[+] 			findAndReplaceUnusedBeacons(symbol->m_resolver);
[-] 		count = symbol->m_productionArray.getCount ();
[+] 		count = symbol->m_productionArray.getCount();
[-] 			findAndReplaceUnusedBeacons (symbol->m_productionArray [i]);
[+] 			findAndReplaceUnusedBeacons(symbol->m_productionArray[i]);
[-] 		sequence = (SequenceNode*) node;
[+] 		sequence = (SequenceNode*)node;
[-] 		count = sequence->m_sequence.getCount ();
[+] 		count = sequence->m_sequence.getCount();
[-] 			findAndReplaceUnusedBeacons (sequence->m_sequence [i]);
[+] 			findAndReplaceUnusedBeacons(sequence->m_sequence[i]);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] ProductionBuilder::findVariable (
[+] ProductionBuilder::findVariable(
[-] 	size_t beaconCount = m_beaconArray.getCount ();
[+] 	size_t beaconCount = m_beaconArray.getCount();
[-] 		err::setFormatStringError ("locator '$%d' is out of range ($1..$%d)", beaconIndex + 1, beaconCount);
[+] 		err::setFormatStringError("locator '$%d' is out of range ($1..$%d)", beaconIndex + 1, beaconCount);
[-] 	BeaconNode* beacon = m_beaconArray [beaconIndex];
[+] 	BeaconNode* beacon = m_beaconArray[beaconIndex];
[-] ProductionBuilder::findVariable (
[+] ProductionBuilder::findVariable(
[-] 	sl::StringHashTableIterator <BeaconNode*> it = m_beaconMap.find (name);
[+] 	sl::StringHashTableIterator<BeaconNode*> it = m_beaconMap.find(name);
[-] 	sl::StringHashTableIterator <bool> it2 = m_symbol->m_localNameSet.find (name);
[+] 	sl::StringHashTableIterator<bool> it2 = m_symbol->m_localNameSet.find(name);
[-] 	it2 = m_symbol->m_argNameSet.find (name);
[+] 	it2 = m_symbol->m_argNameSet.find(name);
[-] 	err::setFormatStringError ("locator '$%s' not found", name.sz ());
[+] 	err::setFormatStringError("locator '$%s' not found", name.sz ());
[-] ProductionBuilder::processUserCode (
[+] ProductionBuilder::processUserCode(
[-] 	Lexer::create (
[+] 	Lexer::create(
[-] 		getMachineState (LexerMachine_UserCode2ndPass),
[+] 		getMachineState(LexerMachine_UserCode2ndPass),
[-] 	setLineCol (srcPos);
[+] 	setLineCol(srcPos);
[-] 		token = getToken ();
[+] 		token = getToken();
[-] 		switch (token->m_token)
[+] 		switch(token->m_token)
[-] 			variableKind = findVariable (token->m_data.m_integer, &beacon);
[+] 			variableKind = findVariable(token->m_data.m_integer, &beacon);
[-] 			variableKind = findVariable (token->m_data.m_string, &beacon);
[+] 			variableKind = findVariable(token->m_data.m_string, &beacon);
[-] 			nextToken ();
[+] 			nextToken();
[-] 		resultString.append (p, token->m_pos.m_p - p);
[+] 		resultString.append(p, token->m_pos.m_p - p);
[-] 		switch (variableKind)
[+] 		switch(variableKind)
[-] 				err::setFormatStringError (
[+] 				err::setFormatStringError(
[-] 					beacon->m_target->m_name.sz ()
[+] 					beacon->m_target->m_name.sz()
[-] 				err::setFormatStringError (
[+] 				err::setFormatStringError(
[-] 					token->getText ().sz ()
[+] 					token->getText().sz()
[-] 					m_dispatcher = m_nodeMgr->createDispatcherNode (m_symbol);
[+] 					m_dispatcher = m_nodeMgr->createDispatcherNode(m_symbol);
[-] 				beacon->m_slotIndex = m_dispatcher->m_beaconArray.getCount ();
[+] 				beacon->m_slotIndex = m_dispatcher->m_beaconArray.getCount();
[-] 				m_dispatcher->m_beaconArray.append (beacon);
[+] 				m_dispatcher->m_beaconArray.append(beacon);
[-] 			resultString.appendFormat ("$%d", beacon->m_slotIndex);
[+] 			resultString.appendFormat("$%d", beacon->m_slotIndex);
[-] 				err::setFormatStringError ("resolvers cannot reference left side of production");
[+] 				err::setFormatStringError("resolvers cannot reference left side of production");
[-] 			resultString.append ('$');
[+] 			resultString.append('$');
[-] 				err::setFormatStringError ("resolvers cannot reference arguments");
[+] 				err::setFormatStringError("resolvers cannot reference arguments");
[-] 			resultString.appendFormat (
[+] 			resultString.appendFormat(
[-] 				token->m_data.m_string.sz ()
[+] 				token->m_data.m_string.sz()
[-] 				err::setFormatStringError ("resolvers cannot reference locals");
[+] 				err::setFormatStringError("resolvers cannot reference locals");
[-] 			resultString.appendFormat (
[+] 			resultString.appendFormat(
[-] 				token->m_data.m_string.sz ()
[+] 				token->m_data.m_string.sz()
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		nextToken ();
[+] 		nextToken();
[-] 	ASSERT (!token->m_token);
[+] 	ASSERT(!token->m_token);
[-] 	resultString.append (p, token->m_pos.m_p - p);
[+] 	resultString.append(p, token->m_pos.m_p - p);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\ClassMgr.h
----------------------
[-] 	Class ()
[+] 	Class()
[-] 	void luaExport (lua::LuaState* luaState);
[+] 	void luaExport(lua::LuaState* luaState);
[-] 	sl::List <Class> m_classList;
[+] 	sl::List<Class> m_classList;
[-] 	sl::StringHashTable <Class*> m_classMap;
[+] 	sl::StringHashTable<Class*> m_classMap;
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 		return m_classList.isEmpty ();
[+] 		return m_classList.isEmpty();
[-] 	getCount ()
[+] 	getCount()
[-] 		return m_classList.getCount ();
[+] 		return m_classList.getCount();
[-] 	sl::Iterator <Class>
[+] 	sl::Iterator<Class>
[-] 	getHead ()
[+] 	getHead()
[-] 		return m_classList.getHead ();
[+] 		return m_classList.getHead();
[-] 	clear ()
[+] 	clear()
[-] 		m_classList.clear ();
[+] 		m_classList.clear();
[-] 		m_classMap.clear ();
[+] 		m_classMap.clear();
[-] 	getClass (const sl::StringRef& name);
[+] 	getClass(const sl::StringRef& name);
[-] 	createUnnamedClass ();
[+] 	createUnnamedClass();
[-] 	findClass (const sl::StringRef& name)
[+] 	findClass(const sl::StringRef& name)
[-] 		sl::StringHashTableIterator <Class*> it = m_classMap.find (name);
[+] 		sl::StringHashTableIterator<Class*> it = m_classMap.find(name);
[-] 	deleteClass (Class* cls);
[+] 	deleteClass(Class* cls);
[-] 	verify ();
[+] 	verify();
[-] 	deleteUnusedClasses ();
[+] 	deleteUnusedClasses();
[-] 	deleteUnreachableClasses ();
[+] 	deleteUnreachableClasses();
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\CmdLine.h
----------------------
[-] 	sl::BoxList <sl::String> m_outputFileNameList;
[+] 	sl::BoxList<sl::String> m_outputFileNameList;
[-] 	sl::BoxList <sl::String> m_frameFileNameList;
[+] 	sl::BoxList<sl::String> m_frameFileNameList;
[-] 	sl::BoxList <sl::String> m_frameDirList;
[+] 	sl::BoxList<sl::String> m_frameDirList;
[-] 	sl::BoxList <sl::String> m_importDirList;
[+] 	sl::BoxList<sl::String> m_importDirList;
[-] 	CmdLine ();
[+] 	CmdLine();
[-] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE (CmdLineSwitchTable, CmdLineSwitchKind)
[+] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE(CmdLineSwitchTable, CmdLineSwitchKind)
[-] 	AXL_SL_CMD_LINE_SWITCH_GROUP ("General options")
[+] 	AXL_SL_CMD_LINE_SWITCH_GROUP("General options")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_GROUP ("Files")
[+] 	AXL_SL_CMD_LINE_SWITCH_GROUP("Files")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_GROUP ("Directories")
[+] 	AXL_SL_CMD_LINE_SWITCH_GROUP("Directories")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] AXL_SL_END_CMD_LINE_SWITCH_TABLE ()
[+] AXL_SL_END_CMD_LINE_SWITCH_TABLE()
[-] class CmdLineParser: public sl::CmdLineParser <CmdLineParser, CmdLineSwitchTable>
[+] class CmdLineParser: public sl::CmdLineParser<CmdLineParser, CmdLineSwitchTable>
[-] 	friend class sl::CmdLineParser <CmdLineParser, CmdLineSwitchTable>;
[+] 	friend class sl::CmdLineParser<CmdLineParser, CmdLineSwitchTable>;
[-] 	CmdLineParser (CmdLine* cmdLine)
[+] 	CmdLineParser(CmdLine* cmdLine)
[-] 	onValue (const sl::StringRef& value);
[+] 	onValue(const sl::StringRef& value);
[-] 	onSwitch (
[+] 	onSwitch(
[-] 	finalize ();
[+] 	finalize();
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\DefineMgr.h
----------------------
[-] 	Define ()
[+] 	Define()
[-] 	sl::List <Define> m_defineList;
[+] 	sl::List<Define> m_defineList;
[-] 	sl::StringHashTable <Define*> m_defineMap;
[+] 	sl::StringHashTable<Define*> m_defineMap;
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 		return m_defineList.isEmpty ();
[+] 		return m_defineList.isEmpty();
[-] 	getCount ()
[+] 	getCount()
[-] 		return m_defineList.getCount ();
[+] 		return m_defineList.getCount();
[-] 	clear ()
[+] 	clear()
[-] 		m_defineList.clear ();
[+] 		m_defineList.clear();
[-] 		m_defineMap.clear ();
[+] 		m_defineMap.clear();
[-] 	sl::Iterator <Define>
[+] 	sl::Iterator<Define>
[-] 	getHead ()
[+] 	getHead()
[-] 		return m_defineList.getHead ();
[+] 		return m_defineList.getHead();
[-] 	getDefine (const sl::StringRef& name);
[+] 	getDefine(const sl::StringRef& name);
[-] 	findDefine (const sl::StringRef& name)
[+] 	findDefine(const sl::StringRef& name)
[-] 		sl::StringHashTableIterator <Define*> it = m_defineMap.find (name);
[+] 		sl::StringHashTableIterator<Define*> it = m_defineMap.find(name);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\Generator.h
----------------------
[-] 	Generator ()
[+] 	Generator()
[-] 	prepare (class Module* module);
[+] 	prepare(class Module* module);
[-] 	generate (
[+] 	generate(
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\LaDfaBuilder.h
----------------------
[-] 	sl::Array <Node*> m_stack;
[+] 	sl::Array<Node*> m_stack;
[-] 	LaDfaThread ();
[+] 	LaDfaThread();
[-] 	sl::List <LaDfaThread> m_activeThreadList;
[+] 	sl::List<LaDfaThread> m_activeThreadList;
[-] 	sl::List <LaDfaThread> m_resolverThreadList;
[+] 	sl::List<LaDfaThread> m_resolverThreadList;
[-] 	sl::List <LaDfaThread> m_completeThreadList;
[+] 	sl::List<LaDfaThread> m_completeThreadList;
[-] 	sl::List <LaDfaThread> m_epsilonThreadList;
[+] 	sl::List<LaDfaThread> m_epsilonThreadList;
[-] 	sl::Array <LaDfaState*> m_transitionArray;
[+] 	sl::Array<LaDfaState*> m_transitionArray;
[-] 	LaDfaState ();
[+] 	LaDfaState();
[-] 	isResolved ()
[+] 	isResolved()
[-] 	isAnyTokenIgnored ()
[+] 	isAnyTokenIgnored()
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 			m_activeThreadList.isEmpty () &&
[+] 			m_activeThreadList.isEmpty() &&
[-] 			m_resolverThreadList.isEmpty () &&
[+] 			m_resolverThreadList.isEmpty() &&
[-] 			m_completeThreadList.isEmpty () &&
[+] 			m_completeThreadList.isEmpty() &&
[-] 			m_epsilonThreadList.isEmpty ();
[+] 			m_epsilonThreadList.isEmpty();
[-] 	calcResolved ();
[+] 	calcResolved();
[-] 	createThread (LaDfaThread* src = NULL);
[+] 	createThread(LaDfaThread* src = NULL);
[-] 	getResolvedProduction ();
[+] 	getResolvedProduction();
[-] 	getDefaultProduction ();
[+] 	getDefaultProduction();
[-] 	sl::List <LaDfaState> m_stateList;
[+] 	sl::List<LaDfaState> m_stateList;
[-] 	sl::Array <Node*>* m_parseTable;
[+] 	sl::Array<Node*>* m_parseTable;
[-] 	LaDfaBuilder (
[+] 	LaDfaBuilder(
[-] 		sl::Array <Node*>* parseTable,
[+] 		sl::Array<Node*>* parseTable,
[-] 	build (
[+] 	build(
[-] 	trace ();
[+] 	trace();
[-] 	getLookahead ()
[+] 	getLookahead()
[-] 	createState ();
[+] 	createState();
[-] 	transition (
[+] 	transition(
[-] 	processThread (
[+] 	processThread(
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\Lexer.h
----------------------
[-] AXL_LEX_BEGIN_TOKEN_NAME_MAP (TokenName)
[+] AXL_LEX_BEGIN_TOKEN_NAME_MAP(TokenName)
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Eof,          "eof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Eof,          "eof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Error,        "error")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Error,        "error")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Identifier,   "identifier")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Identifier,   "identifier")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Integer,      "integer-constant")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Integer,      "integer-constant")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Literal,      "string-literal")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Literal,      "string-literal")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Lookahead,    "lookahead")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Lookahead,    "lookahead")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Import,       "import")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Import,       "import")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Using,        "using")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Using,        "using")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Class,        "class")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Class,        "class")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_NoAst,        "noast")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_NoAst,        "noast")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Default,      "default")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Default,      "default")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Arg,          "arg")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Arg,          "arg")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Local,        "local")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Local,        "local")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Enter,        "enter")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Enter,        "enter")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Leave,        "leave")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Leave,        "leave")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Start,        "start")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Start,        "start")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Pragma,       "pragma")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Pragma,       "pragma")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Resolver,     "resolver")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Resolver,     "resolver")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Priority,     "priority")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Priority,     "priority")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Any,          "any")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Any,          "any")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Epsilon,      "epsilon")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Epsilon,      "epsilon")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Nullable,     "nullable")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Nullable,     "nullable")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OpenBrace,    "{.")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OpenBrace,    "{.")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_CloseBrace,   ".}")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_CloseBrace,   ".}")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OpenChevron,  "<.")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OpenChevron,  "<.")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_CloseChevron, ".>")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_CloseChevron, ".>")
[-] AXL_LEX_END_TOKEN_NAME_MAP ()
[+] AXL_LEX_END_TOKEN_NAME_MAP()
[-] typedef lex::RagelToken <TokenKind, TokenName> Token;
[+] typedef lex::RagelToken<TokenKind, TokenName> Token;
[-] class Lexer: public lex::RagelLexer <Lexer, Token>
[+] class Lexer: public lex::RagelLexer<Lexer, Token>
[-] 	friend class lex::RagelLexer <Lexer, Token>;
[+] 	friend class lex::RagelLexer<Lexer, Token>;
[-] 	getMachineState (LexerMachine machine);
[+] 	getMachineState(LexerMachine machine);
[-] 	createStringToken (
[+] 	createStringToken(
[-] 		Token* token = createToken (tokenKind);
[+] 		Token* token = createToken(tokenKind);
[-] 		token->m_data.m_string = sl::StringRef (ts + left, token->m_pos.m_length - (left + right));
[+] 		token->m_data.m_string = sl::StringRef(ts + left, token->m_pos.m_length - (left + right));
[-] 	createCharToken (int tokenKind)
[+] 	createCharToken(int tokenKind)
[-] 		Token* token = createToken (tokenKind);
[+] 		Token* token = createToken(tokenKind);
[-] 		token->m_data.m_integer = ts [1];
[+] 		token->m_data.m_integer = ts[1];
[-] 	createIntegerToken (
[+] 	createIntegerToken(
[-] 		Token* token = createToken (TokenKind_Integer);
[+] 		Token* token = createToken(TokenKind_Integer);
[-] 		token->m_data.m_integer = strtol (ts + left, NULL, radix);
[+] 		token->m_data.m_integer = strtol(ts + left, NULL, radix);
[-] 	createConstIntegerToken (int value)
[+] 	createConstIntegerToken(int value)
[-] 		Token* token = createToken (TokenKind_Integer);
[+] 		Token* token = createToken(TokenKind_Integer);
[-] 	init ();
[+] 	init();
[-] 	exec ();
[+] 	exec();
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\Module.h
----------------------
[-] 	sl::Array <Node*> m_parseTable;
[+] 	sl::Array<Node*> m_parseTable;
[-] 	sl::BoxList <sl::String> m_importList;
[+] 	sl::BoxList<sl::String> m_importList;
[-] 	Module ();
[+] 	Module();
[-] 	clear ();
[+] 	clear();
[-] 	build (CmdLine* cmdLine);
[+] 	build(CmdLine* cmdLine);
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	trace ();
[+] 	trace();
[-] 	generateBnfString ();
[+] 	generateBnfString();
[-] 	writeBnfFile (const sl::StringRef& fileName);
[+] 	writeBnfFile(const sl::StringRef& fileName);
[-] 	luaExportDefines (lua::LuaState* luaState);
[+] 	luaExportDefines(lua::LuaState* luaState);
[-] 	luaExportClassTable (lua::LuaState* luaState);
[+] 	luaExportClassTable(lua::LuaState* luaState);
[-] 	luaExportParseTable (lua::LuaState* luaState);
[+] 	luaExportParseTable(lua::LuaState* luaState);
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\Node.h
----------------------
[-] 	Node ();
[+] 	Node();
[-] 	~Node ()
[+] 	~Node()
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState)
[+] 	luaExport(lua::LuaState* luaState)
[-] 	isReachable ()
[+] 	isReachable()
[-] 	markReachable ();
[+] 	markReachable();
[-] 	getProductionString ()
[+] 	getProductionString()
[-] 	getBnfString ()
[+] 	getBnfString()
[-] 	sl::Array <SymbolNode*> m_firstArray;
[+] 	sl::Array<SymbolNode*> m_firstArray;
[-] 	sl::Array <SymbolNode*> m_followArray;
[+] 	sl::Array<SymbolNode*> m_followArray;
[-] 	GrammarNode ()
[+] 	GrammarNode()
[-] 	trace ();
[+] 	trace();
[-] 	isNullable ()
[+] 	isNullable()
[-] 	isFinal ()
[+] 	isFinal()
[-] 	markNullable ();
[+] 	markNullable();
[-] 	markFinal ();
[+] 	markFinal();
[-] 	stripBeacon ();
[+] 	stripBeacon();
[-] 	getBnfString ();
[+] 	getBnfString();
[-] 	luaExportSrcPos (
[+] 	luaExportSrcPos(
[-] 	sl::Array <GrammarNode*> m_productionArray;
[+] 	sl::Array<GrammarNode*> m_productionArray;
[-] 	sl::BoxList <sl::String> m_argNameList;
[+] 	sl::BoxList<sl::String> m_argNameList;
[-] 	sl::BoxList <sl::String> m_localNameList;
[+] 	sl::BoxList<sl::String> m_localNameList;
[-] 	sl::StringHashTable <bool> m_argNameSet;
[+] 	sl::StringHashTable<bool> m_argNameSet;
[-] 	sl::StringHashTable <bool> m_localNameSet;
[+] 	sl::StringHashTable<bool> m_localNameSet;
[-] 	SymbolNode ();
[+] 	SymbolNode();
[-] 	getArgName (size_t index);
[+] 	getArgName(size_t index);
[-] 	addProduction (GrammarNode* node);
[+] 	addProduction(GrammarNode* node);
[-] 	markReachable ();
[+] 	markReachable();
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	getBnfString ();
[+] 	getBnfString();
[-] 	sl::Array <GrammarNode*> m_sequence;
[+] 	sl::Array<GrammarNode*> m_sequence;
[-] 	SequenceNode ();
[+] 	SequenceNode();
[-] 	append (GrammarNode* node);
[+] 	append(GrammarNode* node);
[-] 	markReachable ();
[+] 	markReachable();
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	getProductionString ();
[+] 	getProductionString();
[-] 	getBnfString ();
[+] 	getBnfString();
[-] 	UserNode ();
[+] 	UserNode();
[-] 	ActionNode ();
[+] 	ActionNode();
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	getBnfString ()
[+] 	getBnfString()
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	sl::BoxList <sl::String> m_argValueList;
[+] 	sl::BoxList<sl::String> m_argValueList;
[-] 	ArgumentNode ();
[+] 	ArgumentNode();
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	getBnfString ()
[+] 	getBnfString()
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	BeaconNode ();
[+] 	BeaconNode();
[-] 	markReachable ();
[+] 	markReachable();
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	getBnfString ()
[+] 	getBnfString()
[-] 		return m_target ? m_target->getBnfString () : m_name;
[+] 		return m_target ? m_target->getBnfString() : m_name;
[-] 	sl::Array <BeaconNode*> m_beaconArray;
[+] 	sl::Array<BeaconNode*> m_beaconArray;
[-] 	DispatcherNode ()
[+] 	DispatcherNode()
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	sl::Array <GrammarNode*> m_productionArray;
[+] 	sl::Array<GrammarNode*> m_productionArray;
[-] 	ConflictNode ();
[+] 	ConflictNode();
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState)
[+] 	luaExport(lua::LuaState* luaState)
[-] 		ASSERT (false); // all the conflicts should be resolved
[+] 		ASSERT(false); // all the conflicts should be resolved
[-] 	pushError ()
[+] 	pushError()
[-] 		err::pushFormatStringError (
[+] 		err::pushFormatStringError(
[-] 			m_symbol->m_name.sz (),
[+] 			m_symbol->m_name.sz(),
[-] 			m_token->m_name.sz ()
[+] 			m_token->m_name.sz()
[-] 	sl::Array <LaDfaNode*> m_transitionArray;
[+] 	sl::Array<LaDfaNode*> m_transitionArray;
[-] 	LaDfaNode ();
[+] 	LaDfaNode();
[-] 	trace ();
[+] 	trace();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	luaExportResolverMembers (lua::LuaState* luaState);
[+] 	luaExportResolverMembers(lua::LuaState* luaState);
[-] traceNodeList (
[+] traceNodeList(
[-] 	sl::Iterator <T> nodeIt
[+] 	sl::Iterator<T> nodeIt
[-] 	printf ("%s\n", name.sz ());
[+] 	printf("%s\n", name.sz ());
[-] 		printf ("%3d/%-3d\t", node->m_index, node->m_masterIndex);
[+] 		printf("%3d/%-3d\t", node->m_index, node->m_masterIndex);
[-] 		node->trace ();
[+] 		node->trace();
[-] traceNodeArray (
[+] traceNodeArray(
[-] 	const sl::Array <T*>* array
[+] 	const sl::Array<T*>* array
[-] 	printf ("%s\n", name.sz ());
[+] 	printf("%s\n", name.sz ());
[-] 	size_t count = array->getCount ();
[+] 	size_t count = array->getCount();
[-] 		printf ("%3d/%-3d ", node->m_index, node->m_masterIndex);
[+] 		printf("%3d/%-3d ", node->m_index, node->m_masterIndex);
[-] 		node->trace ();
[+] 		node->trace();
[-] nodeArrayToString (const sl::Array <T*>* array)
[+] nodeArrayToString(const sl::Array<T*>* array)
[-] 	size_t count = array->getCount ();
[+] 	size_t count = array->getCount();
[-] 		return sl::String ();
[+] 		return sl::String();
----------------------
27/02/2019 18:01:55 - C:\Projects\repos\ioninja\graco\src\NodeMgr.h
----------------------
[-] 	sl::SimpleHashTable <int, SymbolNode*> m_tokenMap;
[+] 	sl::SimpleHashTable<int, SymbolNode*> m_tokenMap;
[-] 	sl::StringHashTable <SymbolNode*> m_symbolMap;
[+] 	sl::StringHashTable<SymbolNode*> m_symbolMap;
[-] 	sl::List <SymbolNode> m_charTokenList;
[+] 	sl::List<SymbolNode> m_charTokenList;
[-] 	sl::List <SymbolNode> m_namedTokenList;
[+] 	sl::List<SymbolNode> m_namedTokenList;
[-] 	sl::List <SymbolNode> m_namedSymbolList;
[+] 	sl::List<SymbolNode> m_namedSymbolList;
[-] 	sl::List <SymbolNode> m_tempSymbolList;
[+] 	sl::List<SymbolNode> m_tempSymbolList;
[-] 	sl::List <SequenceNode> m_sequenceList;
[+] 	sl::List<SequenceNode> m_sequenceList;
[-] 	sl::List <BeaconNode> m_beaconList;
[+] 	sl::List<BeaconNode> m_beaconList;
[-] 	sl::List <DispatcherNode> m_dispatcherList;
[+] 	sl::List<DispatcherNode> m_dispatcherList;
[-] 	sl::List <ActionNode> m_actionList;
[+] 	sl::List<ActionNode> m_actionList;
[-] 	sl::List <ArgumentNode> m_argumentList;
[+] 	sl::List<ArgumentNode> m_argumentList;
[-] 	sl::List <ConflictNode> m_conflictList;
[+] 	sl::List<ConflictNode> m_conflictList;
[-] 	sl::List <LaDfaNode> m_laDfaList;
[+] 	sl::List<LaDfaNode> m_laDfaList;
[-] 	sl::Array <SymbolNode*> m_tokenArray;  // char tokens + named tokens
[+] 	sl::Array<SymbolNode*> m_tokenArray;  // char tokens + named tokens
[-] 	sl::Array <SymbolNode*> m_symbolArray; // named symbols + temp symbols
[+] 	sl::Array<SymbolNode*> m_symbolArray; // named symbols + temp symbols
[-] 	NodeMgr ();
[+] 	NodeMgr();
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 		return m_namedSymbolList.isEmpty ();
[+] 		return m_namedSymbolList.isEmpty();
[-] 	clear ();
[+] 	clear();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	getTokenNode (int token);
[+] 	getTokenNode(int token);
[-] 	getSymbolNode (const sl::StringRef& name);
[+] 	getSymbolNode(const sl::StringRef& name);
[-] 	createTempSymbolNode ();
[+] 	createTempSymbolNode();
[-] 	createSequenceNode ();
[+] 	createSequenceNode();
[-] 	createSequenceNode (GrammarNode* node);
[+] 	createSequenceNode(GrammarNode* node);
[-] 	createBeaconNode (SymbolNode* target);
[+] 	createBeaconNode(SymbolNode* target);
[-] 	deleteBeaconNode (BeaconNode* node)
[+] 	deleteBeaconNode(BeaconNode* node)
[-] 		m_beaconList.erase (node);
[+] 		m_beaconList.erase(node);
[-] 	deleteLaDfaNode (LaDfaNode* node)
[+] 	deleteLaDfaNode(LaDfaNode* node)
[-] 		m_laDfaList.erase (node);
[+] 		m_laDfaList.erase(node);
[-] 	createDispatcherNode (SymbolNode* symbol);
[+] 	createDispatcherNode(SymbolNode* symbol);
[-] 	createActionNode ();
[+] 	createActionNode();
[-] 	createArgumentNode ();
[+] 	createArgumentNode();
[-] 	createConflictNode ();
[+] 	createConflictNode();
[-] 	createLaDfaNode ();
[+] 	createLaDfaNode();
[-] 	createQuantifierNode (
[+] 	createQuantifierNode(
[-] 	trace ();
[+] 	trace();
[-] 	luaExport ();
[+] 	luaExport();
[-] 	markReachableNodes ();
[+] 	markReachableNodes();
[-] 	deleteUnreachableNodes ();
[+] 	deleteUnreachableNodes();
[-] 	indexTokens ();
[+] 	indexTokens();
[-] 	indexSymbols ();
[+] 	indexSymbols();
[-] 	indexSequences ();
[+] 	indexSequences();
[-] 	indexBeacons ();
[+] 	indexBeacons();
[-] 	indexDispatchers ();
[+] 	indexDispatchers();
[-] 	indexActions ();
[+] 	indexActions();
[-] 	indexArguments ();
[+] 	indexArguments();
[-] 	indexLaDfaNodes ();
[+] 	indexLaDfaNodes();
[-] 	luaExportTokenTable (lua::LuaState* luaState);
[+] 	luaExportTokenTable(lua::LuaState* luaState);
[-] 	luaExportSymbolTable (lua::LuaState* luaState);
[+] 	luaExportSymbolTable(lua::LuaState* luaState);
[-] 	luaExportSequenceTable (lua::LuaState* luaState);
[+] 	luaExportSequenceTable(lua::LuaState* luaState);
[-] 	luaExportLaDfaTable (lua::LuaState* luaState);
[+] 	luaExportLaDfaTable(lua::LuaState* luaState);
[-] 	luaExportNodeArray (
[+] 	luaExportNodeArray(
[-] 	luaExportNodeList (
[+] 	luaExportNodeList(
[-] 		sl::Iterator <Node> node,
[+] 		sl::Iterator<Node> node,
----------------------
27/02/2019 18:01:56 - C:\Projects\repos\ioninja\graco\src\Parser.h
----------------------
[-] 		ProductionSpecifiers ()
[+] 		ProductionSpecifiers()
[-] 			reset ();
[+] 			reset();
[-] 		void reset ()
[+] 		void reset()
[-] 	Parser ()
[+] 	Parser()
[-] 	parse (
[+] 	parse(
[-] 	parseFile (
[+] 	parseFile(
[-] 	program ();
[+] 	program();
[-] 	lookaheadStatement ();
[+] 	lookaheadStatement();
[-] 	importStatement ();
[+] 	importStatement();
[-] 	declarationStatement ();
[+] 	declarationStatement();
[-] 	productionSpecifiers (ProductionSpecifiers* specifiers);
[+] 	productionSpecifiers(ProductionSpecifiers* specifiers);
[-] 	classStatement ();
[+] 	classStatement();
[-] 	usingStatement ();
[+] 	usingStatement();
[-] 	defineStatement ();
[+] 	defineStatement();
[-] 	production (const ProductionSpecifiers* specifiers);
[+] 	production(const ProductionSpecifiers* specifiers);
[-] 	classSpecifier ();
[+] 	classSpecifier();
[-] 	alternative ();
[+] 	alternative();
[-] 	sequence ();
[+] 	sequence();
[-] 	quantifier ();
[+] 	quantifier();
[-] 	primary ();
[+] 	primary();
[-] 	resolver ();
[+] 	resolver();
[-] 	beacon ();
[+] 	beacon();
[-] 	userCode (
[+] 	userCode(
[-] 	userCode (
[+] 	userCode(
[-] 	customizeSymbol (SymbolNode* node);
[+] 	customizeSymbol(SymbolNode* node);
[-] 	processLocalList (SymbolNode* node);
[+] 	processLocalList(SymbolNode* node);
[-] 	processFormalArgList (SymbolNode* node);
[+] 	processFormalArgList(SymbolNode* node);
[-] 	processActualArgList (
[+] 	processActualArgList(
[-] 	processSymbolEventHandler (
[+] 	processSymbolEventHandler(
[-] 	setGrammarNodeSrcPos (
[+] 	setGrammarNodeSrcPos(
[-] 	setGrammarNodeSrcPos (GrammarNode* node)
[+] 	setGrammarNodeSrcPos(GrammarNode* node)
[-] 		setGrammarNodeSrcPos (node, m_lastTokenPos);
[+] 		setGrammarNodeSrcPos(node, m_lastTokenPos);
----------------------
27/02/2019 18:01:56 - C:\Projects\repos\ioninja\graco\src\ParseTableBuilder.h
----------------------
[-] 	sl::Array <Node*>* m_parseTable;
[+] 	sl::Array<Node*>* m_parseTable;
[-] 	ParseTableBuilder (
[+] 	ParseTableBuilder(
[-] 		sl::Array <Node*>* parseTable
[+] 		sl::Array<Node*>* parseTable
[-] 	build ();
[+] 	build();
[-] 	calcFirstFollow ();
[+] 	calcFirstFollow();
[-] 	buildFirstFollowArrays (GrammarNode* node);
[+] 	buildFirstFollowArrays(GrammarNode* node);
[-] 	addProductionToParseTable (
[+] 	addProductionToParseTable(
[-] 	addAnyTokenProductionToParseTable (
[+] 	addAnyTokenProductionToParseTable(
[-] 	addParseTableEntry (
[+] 	addParseTableEntry(
----------------------
27/02/2019 18:01:56 - C:\Projects\repos\ioninja\graco\src\ProductionBuilder.h
----------------------
[-] 	sl::Array <ActionNode*> m_actionArray;
[+] 	sl::Array<ActionNode*> m_actionArray;
[-] 	sl::Array <ArgumentNode*> m_argumentArray;
[+] 	sl::Array<ArgumentNode*> m_argumentArray;
[-] 	sl::Array <BeaconNode*> m_beaconArray;
[+] 	sl::Array<BeaconNode*> m_beaconArray;
[-] 	sl::Array <BeaconNode*> m_beaconDeleteArray;
[+] 	sl::Array<BeaconNode*> m_beaconDeleteArray;
[-] 	sl::StringHashTable <BeaconNode*> m_beaconMap;
[+] 	sl::StringHashTable<BeaconNode*> m_beaconMap;
[-] 	ProductionBuilder (NodeMgr* nodeMgr);
[+] 	ProductionBuilder(NodeMgr* nodeMgr);
[-] 	build (
[+] 	build(
[-] 	scan (GrammarNode* node);
[+] 	scan(GrammarNode* node);
[-] 	addBeacon (BeaconNode* beacon);
[+] 	addBeacon(BeaconNode* beacon);
[-] 	findAndReplaceUnusedBeacons (GrammarNode*& node);
[+] 	findAndReplaceUnusedBeacons(GrammarNode*& node);
[-] 	processAllUserCode ();
[+] 	processAllUserCode();
[-] 	processUserCode (
[+] 	processUserCode(
[-] 	findVariable (
[+] 	findVariable(
[-] 	findVariable (
[+] 	findVariable(
