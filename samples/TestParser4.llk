//.............................................................................
//
// specify output
//
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

generate "TestParser.h" using "TestParserFrame.h";

//.............................................................................
//
// symbol classes
//
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class CScope
{
	members 
	{
	protected:
		axl::rtl::CHashTableMapT <axl::rtl::CString, int, axl::rtl::CHashString, axl::rtl::CCmpString> m_SymbolMap;		

	public:
		bool
		FindValue (
			const tchar_t* pName,
			int* pValue
			)
		{
			axl::rtl::CHashTableMapIteratorT <axl::rtl::CString, int>::T It = m_SymbolMap.Find (pName);
			if (!It)
				return false;

			*pValue = It->m_Value;
			return true;
		}

		void
		Assign (
			const axl::rtl::CString& Name,
			int Value
			)
		{
			m_SymbolMap.Goto (Name)->m_Value = Value;
		}
	}

	leave 
	{
		printf ("CScope::leave ()\n");

		axl::rtl::CHashTableMapIteratorT <axl::rtl::CString, int>::T It = $.m_SymbolMap.GetHead ();
		for (; It; It++)
			printf ("%s = %d\n", It->m_Key, It->m_Value);
	}
};

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class CValue
{
	members 
	{
		int m_Value;

		CValue ()
		{
			m_Value = 0;
		}
	}
};

//.............................................................................
//
// grammar
//
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

program
	: statement*
	;

statement
	: expression_stmt
//	| assignment_stmt
	| compound_stmt
	| declaration
	| ';'
	;

expression_stmt
	: expression ';' { printf ("EXPR = %d\n", $1.m_Value); }
	;

assignment_stmt
	: EToken_Identifier '=' expression ';' { printf ("assign '%s' = %d\n", $1.m_Data.m_String, $3.m_Value); }
	;

CScope
compound_stmt
	: '{' statement* '}'
	;

using CValue;

expression
	: multiplicative { $.m_Value = $1.m_Value; } 
		('+' multiplicative=b { $.m_Value += $b.m_Value; } )*
	;

multiplicative
	: unary { $.m_Value = $1.m_Value; } 
		('*' unary=b { $.m_Value *= $b.m_Value; } )*
	;

unary 
	: '+' unary  { $.m_Value = $2.m_Value; }
	| '-' unary  { $.m_Value = -$2.m_Value; }
	| cast       { $.m_Value = $1.m_Value; }
	| primary    { $.m_Value = $1.m_Value; }
	;

cast
	: ?? { IsType ($2); } '(' EToken_Identifier ')' unary
	;

primary
	: '(' expression ')' { $.m_Value = $2.m_Value; }
	| EToken_Integer     { $.m_Value = $1.m_Data.m_Integer; }
	| EToken_Identifier  { $.m_Value = 0, printf ("identifier '%s'\n", $1.m_Data.m_String); }
	;

//.............................................................................
