//.............................................................................
//
// specify output
//
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

generate "TestParser.h" using "axl_prs_LlParserFrame.h.luaf";

//.............................................................................
//
// symbol classes
//
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class CScope
{
	axl::rtl::CHashTableMapT <axl::rtl::CString, int, axl::rtl::CHashString, axl::rtl::CCmpString> m_SymbolMap;		
	CScope* m_pParentScope;

	CScope ()
	{
		m_pParentScope = NULL;
	}

	void
	Trace ()
	{
		printf ("CScope::Trace ()\n");

		axl::rtl::CHashTableMapIteratorT <axl::rtl::CString, int>::T It = m_SymbolMap.GetHead ();
		for (; It; It++)
			printf ("%s = %d\n", It->m_Key, It->m_Value);
	}

	int*
	Find (const tchar_t* pName)
	{
		axl::rtl::CHashTableMapIteratorT <axl::rtl::CString, int>::T It = m_SymbolMap.Find (pName);
		if (It)
			return &It->m_Value;

		return m_pParentScope ? m_pParentScope->Find (pName) : NULL;
	}

	void
	Assign (
		const axl::rtl::CString& Name,
		int Value
		)
	{
		m_SymbolMap.Goto (Name)->m_Value = Value;
	}
};

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class CValue
{
	int m_Value;

	CValue ()
	{
		m_Value = 0;
	}
};

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

ParserClassName = CParser;

members
{
	CScope m_GlobalScope;
	CScope* m_pCurrentScope;

	CParser ()
	{
		m_pCurrentScope = &m_GlobalScope;
	}
}

//.............................................................................
//
// grammar
//
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

program
	: statement*
	;

statement
	: expression_stmt
	| assignment_stmt
	| compound_stmt
	| ';'
	;

expression_stmt
	: expression ';' { printf ("EXPR = %d\n", $1.m_Value); }
	;

assignment_stmt
	: EToken_Identifier '=' expression ';' 
		{ 
			m_pCurrentScope->Assign ($1.m_Data.m_String, $3.m_Value);
		}
	;

CScope
compound_stmt
	enter
	{
		printf ("compound_stmt::enter ()\n");

		$.m_pParentScope = m_pCurrentScope;
		m_pCurrentScope = &$;
	}

	leave
	{
		printf ("compound_stmt::leave ()\n");

		$.Trace ();
		m_pCurrentScope = $.m_pParentScope;
	}
	: '{' statement* '}'
	;

using CValue;

expression
	: multiplicative { $.m_Value = $1.m_Value; } 
		('+' multiplicative $b { $.m_Value += $b.m_Value; } )*
	;

multiplicative
	: unary { $.m_Value = $1.m_Value; } 
		('*' unary $b { $.m_Value *= $b.m_Value; } )*
	;

unary 
	: '+' unary  { $.m_Value = $2.m_Value; }
	| '-' unary  { $.m_Value = -$2.m_Value; }
	| primary    { $.m_Value = $1.m_Value; }
	;

primary
	: '(' expression ')' { $.m_Value = $2.m_Value; }
	| EToken_Integer     { $.m_Value = $1.m_Data.m_Integer; }
	| EToken_Identifier  
		{ 
			int* p = m_pCurrentScope->Find ($1.m_Data.m_String);
			if (!p)
			{
				axl::err::SetFormatStringError (1005, "undefinded identifier '%s'", $1.m_Data.m_String);
				return false;
			}

			$.m_Value = *p; 
		}
	;

//.............................................................................
