#pragma once

$Includes

// warning C4065: switch statement contains 'default' but no 'case' labels

#pragma warning (disable: 4065)

%{
	-------------------------------------------------------------------------------

	if NoPpLine then
		PpLinePrefix = "//"
	end

	if ParserClassName == nil then
		ParserClassName = "CParser"
	end

	AstNodeVariableName = "__pAstNode"
	SymbolVariableName  = "__pSymbol"

	ClassCount      = #ClassTable
	TokenCount      = #TokenTable
	SymbolCount     = #SymbolTable
	SequenceCount   = #SequenceTable
	ActionCount     = #ActionTable
	ArgumentCount   = #ArgumentTable
	BeaconCount     = #BeaconTable
	DispatcherCount = #DispatcherTable
	LaDfaCount      = #LaDfaTable

	TotalCount      = TokenCount + SymbolCount + SequenceCount + ActionCount + ArgumentCount + BeaconCount + LaDfaCount

	TokenEnd        = TokenCount
	NamedSymbolEnd  = TokenEnd + NamedSymbolCount
	SymbolEnd       = TokenEnd + SymbolCount
	SequenceEnd     = SymbolEnd + SequenceCount
	ActionEnd       = SequenceEnd + ActionCount
	ArgumentEnd     = ActionEnd + ArgumentCount
	BeaconEnd       = ArgumentEnd + BeaconCount
	LaDfaEnd        = BeaconEnd + LaDfaCount

	-------------------------------------------------------------------------------

	function GetPpLine (
		FilePath,
		Line
		)
		return string.format (
			"%d \"%s\"",
			Line + 1,
			string.gsub (FilePath, "\\", "/")
			)
	end 

	function GetPpLineDefault ()
		return GetPpLine (TargetFilePath, GetLine () + 1)
	end 

	function GetTokenString (Token)
		if Token.IsEofToken then
			return "'\\00'"
		elseif Token.IsAnyToken then
			return "'\\01'"
		elseif Token.Name then
			return Token.Name
		else
			TokenChar = string.char (Token.Token)
			if string.match (TokenChar, "[%g ]") then
				return string.format ("'%s'", TokenChar)
			else
				return Token.Token
			end
		end
	end

	-------------------------------------------------------------------------------

	function GetSymbolDeclaration (
		Symbol,
		Name,
		Value
		)
		if Symbol.IsCustom then
			return string.format ("CSymbolNode_%s* %s = (CSymbolNode_%s*) %s;", Symbol.Name, Name, Symbol.Name, Value)
		else
			return string.format ("CSymbolNode* %s = %s;", Name, Value)
		end
	end

	-------------------------------------------------------------------------------

	function GetAstDeclaration (
		Symbol,
		AstName,
		SymbolName
		)
		if Symbol.Class then
			return string.format ("%s* %s = (%s*) %s->m_pAstNode;", Symbol.Class, AstName, Symbol.Class, SymbolName)
		else
			return string.format ("CAstNode* %s = %s->m_pAstNode;", AstName, SymbolName)
		end
	end

	-------------------------------------------------------------------------------
	
	function ProcessActionUserCode (
		UserCode,
		Dispatcher,
		SymbolName,
		AstName
		)		
		return (string.gsub (
			UserCode,
			"%$(%w*)",
			function (s)
				if s == "" or s == "ast" then
					return string.format ("(*%s)", AstName)
				elseif s == "arg" then
					return string.format ("%s->m_Arg", SymbolName)
				elseif s == "local" then
					return string.format ("%s->m_Local", SymbolName)
				elseif not Dispatcher then
					error (string.format ("invalid locator $%s", s))
				else
					SlotIndex = tonumber (s)
					Symbol = Dispatcher.BeaconTable [SlotIndex + 1].Symbol

					if not Symbol then
						return string.format ("(*GetTokenLocator (%d))", SlotIndex)
					elseif Symbol.Class then
						return string.format ("(*(%s*) GetAstLocator (%d))", Symbol.Class, SlotIndex)
					else
						return string.format ("(*GetAstLocator (%d))", SlotIndex)
					end
				end
			end
			)) -- get rid of second value returned by string.gsub
	end

	-------------------------------------------------------------------------------

}

$OpenNamespace

//.............................................................................

enum ESymbol
{
	%{ 
	for i = 1, NamedSymbolCount do
		Symbol = SymbolTable [i] 
		Emit ("ESymbol_", Symbol.Name, " = ", i - 1, ", ")
	}
	%{ end }
};

//.............................................................................

class $ParserClassName: public llk::CParserT <$ParserClassName, CToken>
{
public:
	enum
	{
		Lookahead          = $Lookahead,

		StartSymbol        = $StartSymbol,
		StartPragmaSymbol  = $StartPragmaSymbol,
		EofToken           = 0,
		AnyToken           = 1,

		TokenCount         = $TokenCount,
		SymbolCount        = $SymbolCount,
		SequenceCount      = $SequenceCount,
		ActionCount        = $ActionCount,
		ArgumentCount      = $ArgumentCount,
		BeaconCount        = $BeaconCount,
		LaDfaCount         = $LaDfaCount,

		TotalCount         = $TotalCount,

		NamedSymbolCount   = $NamedSymbolCount,

		TokenFirst         = 0,
		TokenEnd           = $TokenEnd,
		SymbolFirst        = $TokenEnd,
		NamedSymbolEnd     = $NamedSymbolEnd,
		SymbolEnd          = $SymbolEnd,
		SequenceFirst      = $SymbolEnd,
		SequenceEnd        = $SequenceEnd,
		ActionFirst        = $SequenceEnd,
		ActionEnd          = $ActionEnd,
		ArgumentFirst      = $ActionEnd,
		ArgumentEnd        = $ArgumentEnd,
		BeaconFirst        = $ArgumentEnd,
		BeaconEnd          = $BeaconEnd,
		LaDfaFirst         = $BeaconEnd,
		LaDfaEnd           = $LaDfaEnd,
	};

	//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
	
	$Members

	//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

	%{ 
	for i = 1, ClassCount do
		Class = ClassTable [i]
		if Class.BaseClass then 
			BaseClass = Class.BaseClass
		else
			BaseClass = "CAstNode"
		end
	}
	class $(Class.Name): public $BaseClass
	{
	public:
$PpLinePrefix #line $(GetPpLine (Class.SrcPos.FilePath, Class.SrcPos.Line))
		$(Class.Members);
$PpLinePrefix #line $(GetPpLineDefault ())
	};
	%{ end }

	//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

	%{ 
	for i = 1, NamedSymbolCount do
		Symbol = SymbolTable [i] 
		if Symbol.IsCustom then }
	class CSymbolNode_$(Symbol.Name): public CSymbolNode
	{
	public:
			%{ if Symbol.Arg then }
		struct
		{
$PpLinePrefix #line $(GetPpLine (Symbol.SrcPos.FilePath, Symbol.ArgLine))
			$((string.gsub (Symbol.Arg, ",", ";")));
$PpLinePrefix #line $(GetPpLineDefault ())
		} m_Arg;	
			%{ end
			if Symbol.Local then }
		struct
		{
$PpLinePrefix #line $(GetPpLine (Symbol.SrcPos.FilePath, Symbol.LocalLine))
			$(Symbol.Local);
$PpLinePrefix #line $(GetPpLineDefault ())
		} m_Local;	
			%{ end }
		CSymbolNode_$(Symbol.Name) ()
		{
			m_Flags = llk::ESymbolNodeFlag_Named;
			m_Index = ESymbol_$(Symbol.Name);
			%{ if Symbol.Enter then }
			m_Flags |= llk::ESymbolNodeFlag_HasEnter;
			%{ end 
				if Symbol.Leave then }
			m_Flags |= llk::ESymbolNodeFlag_HasLeave;
			%{ end }
		}
	};
		%{ end }
	%{ end }

	//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
	
	$Members2

	//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

	static
	size_t*
	GetParseTable ()
	{
		static
		size_t _ParseTable [] = 
		{
			%{ 
				for i = 1, SymbolCount do
					Row = ParseTable [i]
					for j = 1, TokenCount do
						Emit (Row [j], ", ")
					end }
			%{ end }
			-1
		};

		return _ParseTable;
	}

	static
	size_t*
	GetSequence (size_t Index)
	{
		static
		size_t _SequenceTable [] = 
		{
			%{ 
				for i = 1, SequenceCount do
					Sequence = SequenceTable [i].Sequence
					for j = #Sequence, 1, -1 do 
						Emit (Sequence [j], ", ")
					end } -1, // $(i - 1)
			%{ end }
			-1
		};

		static
		size_t _SequenceIndexTable [] = 
		{
			%{ 
				j = 0;
				for i = 1, SequenceCount do
					Sequence = SequenceTable [i].Sequence
					Emit (j, ", ")
					j = j + #Sequence + 1 -- to account left side & terminating -1 
				end			
			}
			-1
		};

		ASSERT (Index < SequenceCount);
		return _SequenceTable + _SequenceIndexTable [Index];
	}

	static
	size_t
	GetTokenIndex (int Token)
	{
		switch (Token)
		{
		case 0:
			return EofToken;

		%{ 
			for i = 3, TokenCount do
				Token = TokenTable [i]
				TokenString = GetTokenString (Token)
		}
		case $TokenString:
			return $(i - 1);
		%{ end }
		default:
			return AnyToken;
		}
	}

	static
	int
	GetTokenFromIndex (size_t Index)
	{
		static
		const int _TokenTable [] = 
		{
			0,  // eof
			0,  // any token
			%{ 
			for i = 3, TokenCount do
				Token = TokenTable [i] 
				TokenString = GetTokenString (Token)
				Emit (TokenString, ", ")
			}
			%{end}
			0
		};

		ASSERT (Index < TokenCount);
		return _TokenTable [Index];
	}

	static
	const char*
	GetSymbolName (size_t Index)
	{
		static
		const char* _SymbolNameTable [NamedSymbolCount] = 
		{
			%{ 
			for i = 1, NamedSymbolCount do
				Symbol = SymbolTable [i] 
			}"$(Symbol.Name)",
			%{end}
		};

		ASSERT (Index < NamedSymbolCount);
		return _SymbolNameTable [Index];
	}

	static
	CSymbolNode*
	CreateSymbolNode (size_t Index)
	{
		CSymbolNode* pNode;

		switch (Index)
		{
		%{ 
		for i = 1, NamedSymbolCount do
			Symbol = SymbolTable [i] 
			if Symbol.IsCustom then
		}
		case ESymbol_$(Symbol.Name):
			pNode = AXL_MEM_NEW (CSymbolNode_$(Symbol.Name));
			%{	if Symbol.Class then }
			pNode->m_pAstNode = AXL_MEM_NEW ($(Symbol.Class));
			%{ elseif not Symbol.IsNoAst then }
			pNode->m_pAstNode = AXL_MEM_NEW (CAstNode);
			%{ end }
			break;
			%{ elseif Symbol.Enter or Symbol.Leave or Symbol.Class or Symbol.IsNoAst then }
		case ESymbol_$(Symbol.Name):
			pNode = CreateStdSymbolNode (Index);
			pNode->m_Flags |= llk::ESymbolNodeFlag_Named;
				%{ if Symbol.Enter then }
			pNode->m_Flags |= llk::ESymbolNodeFlag_HasEnter;
				%{ end 
					if Symbol.Leave then }
			pNode->m_Flags |= llk::ESymbolNodeFlag_HasLeave;
				%{ end 
					if Symbol.Class then }
			pNode->m_pAstNode = AXL_MEM_NEW ($(Symbol.Class));
				%{ elseif not Symbol.IsNoAst then }
			pNode->m_pAstNode = AXL_MEM_NEW (CAstNode);
				%{ end }
			break;
			%{ end }
		%{ end }
		default:
			pNode = CreateStdSymbolNode (Index);
			pNode->m_pAstNode = AXL_MEM_NEW (CAstNode);
		};

		if (pNode->m_pAstNode)
			pNode->m_pAstNode->m_Kind = (int) Index;

		return pNode;
	}

	static
	size_t*
	GetBeacon (size_t Index)
	{
		static
		size_t _BeaconTable [] [2] = 
		{
			%{ 
				for i = 1, BeaconCount do
					local Beacon = BeaconTable [i]
			}
			{ $(Beacon.Slot), $(Beacon.Target) },
			%{ end }
			{ 0 }
		};

		ASSERT (Index < BeaconCount);
		return _BeaconTable [Index];
	}

	bool
	Action (size_t Index)
	{
		switch (Index)
		{
		%{ 
			for i = 1, ActionCount do
				Action = ActionTable [i]
				ProductionSymbol = Action.ProductionSymbol;
		}
		case $(i - 1):
			{
			$(GetSymbolDeclaration (ProductionSymbol, SymbolVariableName, "GetSymbolTop ()"))
			$(GetAstDeclaration (ProductionSymbol, AstNodeVariableName, SymbolVariableName))
$PpLinePrefix #line $(GetPpLine (Action.SrcPos.FilePath, Action.SrcPos.Line))
			$(ProcessActionUserCode (Action.UserCode, Action.Dispatcher, SymbolVariableName, AstNodeVariableName));
$PpLinePrefix #line $(GetPpLineDefault ())
			}

			return true;
		%{ end }
		default:
			ASSERT (false);
			return true;
		}
	}

	void
	Argument (
		size_t Index,
		CSymbolNode* pSymbol
		)
	{
		switch (Index)
		{
		%{ 
			for i = 1, ArgumentCount do
				Argument = ArgumentTable [i]
				TargetSymbol = Argument.TargetSymbol
				ProductionSymbol = Argument.ProductionSymbol
				ValueTable = Argument.ValueTable 
			}
		case $(i - 1):
			{
			$(GetSymbolDeclaration (TargetSymbol, "__pTarget", "pSymbol"))
			$(GetSymbolDeclaration (ProductionSymbol, SymbolVariableName, "GetSymbolTop ()"))
			$(GetAstDeclaration (ProductionSymbol, AstNodeVariableName, SymbolVariableName))
			%{ for j = 1, #ValueTable do
				ArgumentName = TargetSymbol.ArgNameTable [j]
				ArgumentValue = ProcessActionUserCode (ValueTable [j], Argument.Dispatcher, SymbolVariableName, AstNodeVariableName)
				}
$PpLinePrefix #line $(GetPpLine (Argument.SrcPos.FilePath, Argument.SrcPos.Line))
			__pTarget->m_Arg.$ArgumentName = $ArgumentValue;
$PpLinePrefix #line $(GetPpLineDefault ())
			%{ end }
			}
			break;
		%{ end }
		default:
			ASSERT (false);
		}
	}

	bool
	Enter (size_t Index)
	{
		switch (Index)
		{
		%{ 
		for i = 1, NamedSymbolCount do
			Symbol = SymbolTable [i] 
			if (Symbol.Enter) then }
		case ESymbol_$(Symbol.Name):
			{
				$(GetSymbolDeclaration (Symbol, SymbolVariableName, "GetSymbolTop ()"))
				$(GetAstDeclaration (Symbol, AstNodeVariableName, SymbolVariableName))
$PpLinePrefix #line $(GetPpLine (Symbol.SrcPos.FilePath, Symbol.EnterLine))
				$(ProcessActionUserCode (Symbol.Enter, nil, SymbolVariableName, AstNodeVariableName));
$PpLinePrefix #line $(GetPpLineDefault ())
			}
			return true;
			%{ end }
		%{ end }
		default:
			return true;
		}
	}

	bool
	Leave (size_t Index)
	{
		switch (Index)
		{
		%{ 
		for i = 1, NamedSymbolCount do
			Symbol = SymbolTable [i] 
			if (Symbol.Leave) then }
		case ESymbol_$(Symbol.Name):
			{
				$(GetSymbolDeclaration (Symbol, SymbolVariableName, "GetSymbolTop ()"))
				$(GetAstDeclaration (Symbol, AstNodeVariableName, SymbolVariableName))
$PpLinePrefix #line $(GetPpLine (Symbol.SrcPos.FilePath, Symbol.LeaveLine))
				$(ProcessActionUserCode (Symbol.Leave, nil, SymbolVariableName, AstNodeVariableName));
$PpLinePrefix #line $(GetPpLineDefault ())
			}
			return true;
			%{ end }
		%{ end }
		default:
			return true;
		}
	}

	ELaDfaResult
	LaDfa (
		size_t Index,
		int LookaheadToken,
		TLaDfaTransition* pTransition
		)
	{
		switch (Index)
		{
		%{ for i = 1, LaDfaCount do
				DfaNode = LaDfaTable [i]	}
		case $(i - 1):
			%{ if DfaNode.Resolver then }
			pTransition->m_ProductionIndex = $(DfaNode.Production);
			pTransition->m_ResolverIndex = $(DfaNode.Resolver);
			pTransition->m_ResolverElseIndex = $(DfaNode.ResolverElse);
				%{ if DfaNode.HasChainedResolver then }
			pTransition->m_Flags = llk::ELaDfaNodeFlag_HasChainedResolver;
				%{ end }
			return ELaDfaResult_Resolver;
			%{ else }
			switch (LookaheadToken)
			{
			%{ TransitionTable = DfaNode.TransitionTable
				for j = 1, #TransitionTable do
					local Transition = TransitionTable [j]
					local TokenString = GetTokenString (Transition.Token) }
			case $TokenString:
					%{ if (Transition.Resolver) then }
				pTransition->m_ProductionIndex = $(Transition.Production);
				pTransition->m_ResolverIndex = $(Transition.Resolver);
				pTransition->m_ResolverElseIndex = $(Transition.ResolverElse);
						%{ if Transition.HasChainedResolver then }
				pTransition->m_Flags = llk::ELaDfaNodeFlag_HasChainedResolver;
						%{ end }
				return ELaDfaResult_Resolver;
					%{ else }
				pTransition->m_ProductionIndex = $(Transition.Production);
				return ELaDfaResult_Production;
					%{ end	}
			%{ end }
			default:
					%{ if (DfaNode.DefaultProduction) then }
				pTransition->m_ProductionIndex = $(DfaNode.DefaultProduction);
				return ELaDfaResult_Production;
					%{ else }				
				return ELaDfaResult_Fail;
					%{ end	}
			}
			%{ end }
		%{ end }
		default:
			return ELaDfaResult_Fail;
		}
	}
};

//.............................................................................

$CloseNamespace

#pragma warning (default: 4065)
